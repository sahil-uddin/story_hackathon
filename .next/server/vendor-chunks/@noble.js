"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./app/node_modules/@noble/curves/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./app/node_modules/@noble/curves/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createCurve = exports.getHash = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./app/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, weierstrass_js_1.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n}\nexports.createCurve = createCurve; //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzdDLG9FQUFvRSxHQUNwRSxNQUFNSSxTQUFTQyxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDM0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsNEVBQXFCO0FBQzdDLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsaUdBQTJCO0FBQzVELHdDQUF3QztBQUN4QyxTQUFTRixRQUFRSyxJQUFJO0lBQ2pCLE9BQU87UUFDSEE7UUFDQUMsTUFBTSxDQUFDQyxLQUFLLEdBQUdDLE9BQVMsQ0FBQyxHQUFHUCxPQUFPSyxJQUFJLEVBQUVELE1BQU1FLEtBQUssQ0FBQyxHQUFHSixRQUFRTSxXQUFXLEtBQUtEO1FBQ2hGRSxhQUFhUCxRQUFRTyxXQUFXO0lBQ3BDO0FBQ0o7QUFDQWIsZUFBZSxHQUFHRztBQUNsQixTQUFTRCxZQUFZWSxRQUFRLEVBQUVDLE9BQU87SUFDbEMsTUFBTUMsU0FBUyxDQUFDUixPQUFTLENBQUMsR0FBR0QsaUJBQWlCVSxXQUFXLEVBQUU7WUFBRSxHQUFHSCxRQUFRO1lBQUUsR0FBR1gsUUFBUUssS0FBSztRQUFDO0lBQzNGLE9BQU9WLE9BQU9vQixNQUFNLENBQUM7UUFBRSxHQUFHRixPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDdEQ7QUFDQWhCLG1CQUFtQixHQUFHRSxhQUN0Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzLmpzPzAzNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gZXhwb3J0cy5nZXRIYXNoID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgaG1hY18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+ICgwLCBobWFjXzEuaG1hYykoaGFzaCwga2V5LCAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbmZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+ICgwLCB3ZWllcnN0cmFzc19qc18xLndlaWVyc3RyYXNzKSh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gY3JlYXRlQ3VydmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUN1cnZlIiwiZ2V0SGFzaCIsImhtYWNfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwid2VpZXJzdHJhc3NfanNfMSIsImhhc2giLCJobWFjIiwia2V5IiwibXNncyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJjdXJ2ZURlZiIsImRlZkhhc2giLCJjcmVhdGUiLCJ3ZWllcnN0cmFzcyIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./app/node_modules/@noble/curves/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nexports.validateBasic = validateBasic; //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxZQUFZLEdBQUcsS0FBSztBQUM1QyxvRUFBb0UsR0FDcEUsMEJBQTBCO0FBQzFCLE1BQU1JLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1FLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQiw2REFBNkQ7QUFDN0QsbUdBQW1HO0FBQ25HLHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsK0VBQStFO0FBQy9FLG9HQUFvRztBQUNwRyxvR0FBb0c7QUFDcEcscUNBQXFDO0FBQ3JDLGtHQUFrRztBQUNsRyxnR0FBZ0c7QUFDaEcsOENBQThDO0FBQzlDLFNBQVNMLEtBQUtPLENBQUMsRUFBRUMsSUFBSTtJQUNqQixNQUFNQyxrQkFBa0IsQ0FBQ0MsV0FBV0M7UUFDaEMsTUFBTUMsTUFBTUQsS0FBS0UsTUFBTTtRQUN2QixPQUFPSCxZQUFZRSxNQUFNRDtJQUM3QjtJQUNBLE1BQU1HLE9BQU8sQ0FBQ0M7UUFDVixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNWLE9BQU9PLEtBQUssR0FBRyxjQUFjO1FBQ3ZELE1BQU1JLGFBQWEsS0FBTUosQ0FBQUEsSUFBSSxJQUFJLDBCQUEwQjtRQUMzRCxPQUFPO1lBQUVDO1lBQVNHO1FBQVc7SUFDakM7SUFDQSxPQUFPO1FBQ0hWO1FBQ0EsdUNBQXVDO1FBQ3ZDVyxjQUFhQyxHQUFHLEVBQUVDLENBQUM7WUFDZixJQUFJQyxJQUFJaEIsRUFBRWlCLElBQUk7WUFDZCxJQUFJQyxJQUFJSjtZQUNSLE1BQU9DLElBQUlsQixJQUFLO2dCQUNaLElBQUlrQixJQUFJaEIsS0FDSmlCLElBQUlBLEVB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Q3BDO1lBQ0o7WUFDQSxPQUFPLElBQUksQ0FBQ3JELElBQUksQ0FBQ2UsR0FBR3NDLE1BQU0vQjtRQUM5QjtJQUNKO0FBQ0o7QUFDQXpCLFlBQVksR0FBR0c7QUFDZixTQUFTRCxjQUFjeUQsS0FBSztJQUN2QixJQUFHdkQsYUFBYXdELGFBQWEsRUFBRUQsTUFBTUUsRUFBRTtJQUN2QyxJQUFHdkQsV0FBV3dELGNBQWMsRUFBRUgsT0FBTztRQUNsQ2xDLEdBQUc7UUFDSHNDLEdBQUc7UUFDSEMsSUFBSTtRQUNKQyxJQUFJO0lBQ1IsR0FBRztRQUNDQyxZQUFZO1FBQ1pDLGFBQWE7SUFDakI7SUFDQSxlQUFlO0lBQ2YsT0FBT3JFLE9BQU9zRSxNQUFNLENBQUM7UUFDakIsR0FBRyxDQUFDLEdBQUdoRSxhQUFhaUUsT0FBTyxFQUFFVixNQUFNbEMsQ0FBQyxFQUFFa0MsTUFBTU8sVUFBVSxDQUFDO1FBQ3ZELEdBQUdQLEtBQUs7UUFDUixHQUFHO1lBQUVqQyxHQUFHaUMsTUFBTUUsRUFBRSxDQUFDUyxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKO0FBQ0F0RSxxQkFBcUIsR0FBR0UsZUFDeEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanM/MzI2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IGV4cG9ydHMud05BRiA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5mdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMud05BRiA9IHdOQUY7XG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgKDAsIG1vZHVsYXJfanNfMS52YWxpZGF0ZUZpZWxkKShjdXJ2ZS5GcCk7XG4gICAgKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uKDAsIG1vZHVsYXJfanNfMS5uTGVuZ3RoKShjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IHZhbGlkYXRlQmFzaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2YWxpZGF0ZUJhc2ljIiwid05BRiIsIm1vZHVsYXJfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiYyIsImJpdHMiLCJjb25zdFRpbWVOZWdhdGUiLCJjb25kaXRpb24iLCJpdGVtIiwibmVnIiwibmVnYXRlIiwib3B0cyIsIlciLCJ3aW5kb3dzIiwiTWF0aCIsImNlaWwiLCJ3aW5kb3dTaXplIiwidW5zYWZlTGFkZGVyIiwiZWxtIiwibiIsInAiLCJaRVJPIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJwb2ludHMiLCJiYXNlIiwid2luZG93IiwicHVzaCIsImkiLCJwcmVjb21wdXRlcyIsImYiLCJCQVNFIiwibWFzayIsIm1heE51bWJlciIsInNoaWZ0QnkiLCJvZmZzZXQiLCJ3Yml0cyIsIk51bWJlciIsIm9mZnNldDEiLCJvZmZzZXQyIiwiYWJzIiwiY29uZDEiLCJjb25kMiIsIndOQUZDYWNoZWQiLCJQIiwicHJlY29tcHV0ZXNNYXAiLCJ0cmFuc2Zvcm0iLCJfV0lORE9XX1NJWkUiLCJjb21wIiwiZ2V0Iiwic2V0IiwiY3VydmUiLCJ2YWxpZGF0ZUZpZWxkIiwiRnAiLCJ2YWxpZGF0ZU9iamVjdCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiZnJlZXplIiwibkxlbmd0aCIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./app/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === \"string\") return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n}\nexports.createHasher = createHasher; //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxxQkFBcUIsR0FBR0EsMEJBQTBCLEdBQUdBLDBCQUEwQixHQUFHLEtBQUs7QUFDbkksTUFBTU8sZUFBZUMsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsU0FBU0UsWUFBWUMsR0FBRztJQUNwQixJQUFJQSxlQUFlQyxZQUNmLE9BQU9EO0lBQ1gsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsT0FBTyxDQUFDLEdBQUdGLFdBQVdJLFdBQVcsRUFBRUY7SUFDdkMsTUFBTSxJQUFJRyxNQUFNO0FBQ3BCO0FBQ0EsNkZBQTZGO0FBQzdGLE1BQU1DLFFBQVFOLFdBQVdPLGVBQWU7QUFDeEMsNENBQTRDO0FBQzVDLFNBQVNDLE1BQU1oQixLQUFLLEVBQUVpQixNQUFNO0lBQ3hCLElBQUlqQixRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJaUIsUUFBUztRQUN6QyxNQUFNLElBQUlKLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRWIsTUFBTSxRQUFRLEVBQUVpQixPQUFPLENBQUM7SUFDckU7SUFDQSxNQUFNQyxNQUFNQyxNQUFNQyxJQUFJLENBQUM7UUFBRUg7SUFBTyxHQUFHSSxJQUFJLENBQUM7SUFDeEMsSUFBSyxJQUFJQyxJQUFJTCxTQUFTLEdBQUdLLEtBQUssR0FBR0EsSUFBSztRQUNsQ0osR0FBRyxDQUFDSSxFQUFFLEdBQUd0QixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlXLFdBQVdPO0FBQzFCO0FBQ0EsU0FBU0ssT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSWYsV0FBV2EsRUFBRVAsTUFB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QUFvQjtRQUM3RCxPQUFPO1lBQUVMO1lBQUdDO1FBQUU7SUFDbEI7QUFDSjtBQUNBbEYsa0JBQWtCLEdBQUdHO0FBQ3JCLFNBQVNELGFBQWEyRixLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRztJQUN4QyxJQUFJLE9BQU9ELGVBQWUsWUFDdEIsTUFBTSxJQUFJaEYsTUFBTTtJQUNwQixPQUFPO1FBQ0gseUNBQXlDO1FBQ3pDLHNFQUFzRTtRQUN0RWtGLGFBQVkvRCxHQUFHLEVBQUV5QixPQUFPO1lBQ3BCLE1BQU1ZLElBQUlsRSxjQUFjNkIsS0FBSyxHQUFHO2dCQUFFLEdBQUc4RCxHQUFHO2dCQUFFN0QsS0FBSzZELElBQUk3RCxHQUFHO2dCQUFFLEdBQUd3QixPQUFPO1lBQUM7WUFDbkUsTUFBTXVDLEtBQUtKLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3hCLENBQUMsQ0FBQyxFQUFFO1lBQzNDLE1BQU02QixLQUFLTixNQUFNSyxVQUFVLENBQUNKLFdBQVd4QixDQUFDLENBQUMsRUFBRTtZQUMzQyxNQUFNOEIsSUFBSUgsR0FBR1AsR0FBRyxDQUFDUyxJQUFJRSxhQUFhO1lBQ2xDRCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7UUFDQSx5Q0FBeUM7UUFDekMsd0VBQXdFO1FBQ3hFRyxlQUFjdEUsR0FBRyxFQUFFeUIsT0FBTztZQUN0QixNQUFNWSxJQUFJbEUsY0FBYzZCLEtBQUssR0FBRztnQkFBRSxHQUFHOEQsR0FBRztnQkFBRTdELEtBQUs2RCxJQUFJUyxTQUFTO2dCQUFFLEdBQUc5QyxPQUFPO1lBQUM7WUFDekUsTUFBTTBDLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3hCLENBQUMsQ0FBQyxFQUFFLEdBQUcrQixhQUFhO1lBQzFERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKO0FBQ0FwRyxvQkFBb0IsR0FBR0UsY0FDdkIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8zZjljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBleHBvcnRzLmlzb2dlbnlNYXAgPSBleHBvcnRzLmhhc2hfdG9fZmllbGQgPSBleHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gdm9pZCAwO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlRFNUKGRzdCkge1xuICAgIGlmIChkc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKShkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gaXNOdW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94bWQgPSBleHBhbmRfbWVzc2FnZV94bWQ7XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cGFuZF9tZXNzYWdlX3hvZjtcbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKShvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydHMuaGFzaF90b19maWVsZCA9IGhhc2hfdG9fZmllbGQ7XG5mdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnRzLmlzb2dlbnlNYXAgPSBpc29nZW55TWFwO1xuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJoYXNoX3RvX2ZpZWxkIiwiZXhwYW5kX21lc3NhZ2VfeG9mIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibW9kdWxhcl9qc18xIiwicmVxdWlyZSIsInV0aWxzX2pzXzEiLCJ2YWxpZGF0ZURTVCIsImRzdCIsIlVpbnQ4QXJyYXkiLCJ1dGY4VG9CeXRlcyIsIkVycm9yIiwib3MyaXAiLCJieXRlc1RvTnVtYmVyQkUiLCJpMm9zcCIsImxlbmd0aCIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpc0J5dGVzIiwiaXRlbSIsImlzTnVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm1zZyIsIkRTVCIsImxlbkluQnl0ZXMiLCJIIiwiY29uY2F0Qnl0ZXMiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJjb3VudCIsIm9wdGlvbnMiLCJ2YWxpZGF0ZU9iamVjdCIsInAiLCJtIiwiaGFzaCIsImV4cGFuZCIsIl9EU1QiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwibW9kIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/abstract/modular.js":
/*!************************************************************!*\
  !*** ./app/node_modules/@noble/curves/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nexports.invert = invert;\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\nexports.nLength = nLength;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar;\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\nexports.getFieldBytesLength = getFieldBytesLength;\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\nexports.getMinHashLength = getMinHashLength;\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\nexports.mapHashToField = mapHashToField; //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSwyQkFBMkIsR0FBR0EsMkJBQTJCLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0EsYUFBYSxHQUFHQSxlQUFlLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLHFCQUFxQixHQUFHQSxhQUFhLEdBQUdBLHFCQUFxQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHQSxxQkFBcUIsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHLEtBQUs7QUFDamEsb0VBQW9FLEdBQ3BFLHNEQUFzRDtBQUN0RCxNQUFNc0IsYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsa0JBQWtCO0FBQ2xCLE1BQU1DLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU1KLE9BQU8sSUFBSUssTUFBTUwsT0FBTyxJQUFJTSxNQUFNTixPQUFPO0FBQ3JELGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNUCxPQUFPLElBQUlRLE9BQU9SLE9BQU87QUFDckMsd0JBQXdCO0FBQ3hCLFNBQVNKLElBQUlhLENBQUMsRUFBRUMsQ0FBQztJQUNiLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVVaLE1BQU1ZLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0FwQyxXQUFXLEdBQUdxQjtBQUNkOzs7OztDQUtDLEdBQ0Qsb0NBQW9DO0FBQ3BDLFNBQVNELElBQUlpQixHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUMzQixJQUFJQSxVQUFVZixPQUFPYyxRQUFRZCxLQUN6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QUFNO0lBQ3BCLE1BQU00RyxZQUFZRCxXQUFXckMsUUFBUSxDQUFDLEdBQUdiLE1BQU07SUFDL0MsT0FBT2UsS0FBS0MsSUFBSSxDQUFDbUMsWUFBWTtBQUNqQztBQUNBcEosMkJBQTJCLEdBQUdJO0FBQzlCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELGlCQUFpQmdKLFVBQVU7SUFDaEMsTUFBTWxELFNBQVM3RixvQkFBb0IrSTtJQUNuQyxPQUFPbEQsU0FBU2UsS0FBS0MsSUFBSSxDQUFDaEIsU0FBUztBQUN2QztBQUNBakcsd0JBQXdCLEdBQUdHO0FBQzNCOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNELGVBQWVtSixHQUFHLEVBQUVGLFVBQVUsRUFBRWhDLE9BQU8sS0FBSztJQUNqRCxNQUFNbUMsTUFBTUQsSUFBSXBELE1BQU07SUFDdEIsTUFBTXNELFdBQVduSixvQkFBb0IrSTtJQUNyQyxNQUFNRCxTQUFTL0ksaUJBQWlCZ0o7SUFDaEMsaUdBQWlHO0lBQ2pHLElBQUlHLE1BQU0sTUFBTUEsTUFBTUosVUFBVUksTUFBTSxNQUNsQyxNQUFNLElBQUk5RyxNQUFNLENBQUMsU0FBUyxFQUFFMEcsT0FBTywwQkFBMEIsRUFBRUksSUFBSSxDQUFDO0lBQ3hFLE1BQU1qSCxNQUFNOEUsT0FBTyxDQUFDLEdBQUc3RixXQUFXc0gsZUFBZSxFQUFFUyxPQUFPLENBQUMsR0FBRy9ILFdBQVdxSCxlQUFlLEVBQUVVO0lBQzFGLCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVbkksSUFBSWdCLEtBQUs4RyxhQUFhekgsT0FBT0E7SUFDN0MsT0FBT3lGLE9BQU8sQ0FBQyxHQUFHN0YsV0FBV2lILGVBQWUsRUFBRWlCLFNBQVNELFlBQVksQ0FBQyxHQUFHakksV0FBV2tILGVBQWUsRUFBRWdCLFNBQVNEO0FBQ2hIO0FBQ0F2SixzQkFBc0IsR0FBR0UsZ0JBQ3pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXIuanM/MDk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBleHBvcnRzLmdldE1pbkhhc2hMZW5ndGggPSBleHBvcnRzLmdldEZpZWxkQnl0ZXNMZW5ndGggPSBleHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBleHBvcnRzLkZwU3FydEV2ZW4gPSBleHBvcnRzLkZwU3FydE9kZCA9IGV4cG9ydHMuRmllbGQgPSBleHBvcnRzLm5MZW5ndGggPSBleHBvcnRzLkZwSXNTcXVhcmUgPSBleHBvcnRzLkZwRGl2ID0gZXhwb3J0cy5GcEludmVydEJhdGNoID0gZXhwb3J0cy5GcFBvdyA9IGV4cG9ydHMudmFsaWRhdGVGaWVsZCA9IGV4cG9ydHMuaXNOZWdhdGl2ZUxFID0gZXhwb3J0cy5GcFNxcnQgPSBleHBvcnRzLnRvbmVsbGlTaGFua3MgPSBleHBvcnRzLmludmVydCA9IGV4cG9ydHMucG93MiA9IGV4cG9ydHMucG93ID0gZXhwb3J0cy5tb2QgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmV4cG9ydHMubW9kID0gbW9kO1xuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5mdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnBvdyA9IHBvdztcbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnBvdzIgPSBwb3cyO1xuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5mdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5mdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuZXhwb3J0cy5GcFNxcnQgPSBGcFNxcnQ7XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5leHBvcnRzLmlzTmVnYXRpdmVMRSA9IGlzTmVnYXRpdmVMRTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGZpZWxkLCBvcHRzKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVGaWVsZCA9IHZhbGlkYXRlRmllbGQ7XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5mdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuZXhwb3J0cy5GcFBvdyA9IEZwUG93O1xuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0cy5GcEludmVydEJhdGNoID0gRnBJbnZlcnRCYXRjaDtcbmZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuZXhwb3J0cy5GcERpdiA9IEZwRGl2O1xuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5mdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuRnBJc1NxdWFyZSA9IEZwSXNTcXVhcmU7XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG5leHBvcnRzLm5MZW5ndGggPSBuTGVuZ3RoO1xuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogKDAsIHV0aWxzX2pzXzEuYml0TWFzaykoQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShudW0sIEJZVEVTKSA6ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5mdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0cy5GcFNxcnRPZGQgPSBGcFNxcnRPZGQ7XG5mdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbmV4cG9ydHMuRnBTcXJ0RXZlbiA9IEZwU3FydEV2ZW47XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkgOiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGhhc2hUb1ByaXZhdGVTY2FsYXI7XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuZXhwb3J0cy5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aDtcbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5mdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG5leHBvcnRzLmdldE1pbkhhc2hMZW5ndGggPSBnZXRNaW5IYXNoTGVuZ3RoO1xuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShrZXkpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckxFKShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKHJlZHVjZWQsIGZpZWxkTGVuKSA6ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuZXhwb3J0cy5tYXBIYXNoVG9GaWVsZCA9IG1hcEhhc2hUb0ZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXBIYXNoVG9GaWVsZCIsImdldE1pbkhhc2hMZW5ndGgiLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsIkZwU3FydEV2ZW4iLCJGcFNxcnRPZGQiLCJGaWVsZCIsIm5MZW5ndGgiLCJGcElzU3F1YXJlIiwiRnBEaXYiLCJGcEludmVydEJhdGNoIiwiRnBQb3ciLCJ2YWxpZGF0ZUZpZWxkIiwiaXNOZWdhdGl2ZUxFIiwiRnBTcXJ0IiwidG9uZWxsaVNoYW5rcyIsImludmVydCIsInBvdzIiLCJwb3ciLCJtb2QiLCJ1dGlsc19qc18xIiwicmVxdWlyZSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl84biIsIl85biIsIl8xNm4iLCJhIiwiYiIsInJlc3VsdCIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRXJyb3IiLCJyZXMiLCJ4IiwibnVtYmVyIiwieSIsInUiLCJ2IiwicSIsInIiLCJtIiwibiIsImdjZCIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsIkZJRUxEX0ZJRUxEUyIsImZpZWxkIiwiaW5pdGlhbCIsIk9SREVSIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJ2YWxpZGF0ZU9iamVjdCIsImYiLCJwIiwiZCIsIm51bXMiLCJ0bXAiLCJBcnJheSIsImxlbmd0aCIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaXMwIiwiaW52ZXJ0ZWQiLCJpbnYiLCJyZWR1Y2VSaWdodCIsImxocyIsInJocyIsImxlZ2VuZHJlQ29uc3QiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsImZyZWV6ZSIsImJpdE1hc2siLCJjcmVhdGUiLCJpc1ZhbGlkIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwic3FydCIsImludmVydEJhdGNoIiwibHN0IiwiY21vdiIsImMiLCJ0b0J5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9CeXRlc0JFIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJieXRlc1RvTnVtYmVyTEUiLCJieXRlc1RvTnVtYmVyQkUiLCJlbG0iLCJoYXNoIiwiZ3JvdXBPcmRlciIsImVuc3VyZUJ5dGVzIiwiaGFzaExlbiIsIm1pbkxlbiIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./app/node_modules/@noble/curves/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject; // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxzQkFBc0IsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsMEJBQTBCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLDJCQUEyQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ3RiLG9FQUFvRSxHQUNwRSwwRUFBMEU7QUFDMUUsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRSx1Q0FBdUM7QUFDdkMsTUFBTXFCLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsTUFBTUMsUUFBUSxhQUFhLEdBQUdDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0Y7O0NBRUMsR0FDRCxTQUFTZixXQUFXZ0IsS0FBSztJQUNyQixJQUFJLENBQUNYLElBQUlXLFFBQ0wsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlHLE1BQU1MLE1BQU0sRUFBRUUsSUFBSztRQUNuQ0ssT0FBT1YsS0FBSyxDQUFDUSxLQUFLLENBQUNILEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9L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LFlBQVksRUFBRWlCLEtBQUssQ0FBQztRQUNqRztJQUNKO0lBQ0EsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSS9HLE9BQU9tSCxPQUFPLENBQUNSLFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUkvRyxPQUFPbUgsT0FBTyxDQUFDUCxlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVDtBQUNYO0FBQ0FwRyxzQkFBc0IsR0FBR0UsZ0JBQ3pCLHNCQUFzQjtDQUN0Qix1RUFBdUU7Q0FDdkUsZ0ZBQWdGO0NBQ2hGLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0QscUVBQXFFO0NBQ3JFLCtEQUErRDtDQUMvRCw0REFBNEQ7Q0FDNUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanM/YzE4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSBleHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gZXhwb3J0cy5iaXRNYXNrID0gZXhwb3J0cy5iaXRTZXQgPSBleHBvcnRzLmJpdEdldCA9IGV4cG9ydHMuYml0TGVuID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuZXF1YWxCeXRlcyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLmVuc3VyZUJ5dGVzID0gZXhwb3J0cy5udW1iZXJUb1ZhckJ5dGVzQkUgPSBleHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IGV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBieXRlc1RvTnVtYmVyQkU7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJMRSA9IGJ5dGVzVG9OdW1iZXJMRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IG51bWJlclRvQnl0ZXNMRTtcbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW5zdXJlQnl0ZXMgPSBlbnN1cmVCeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG5leHBvcnRzLmJpdExlbiA9IGJpdExlbjtcbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG5leHBvcnRzLmJpdEdldCA9IGJpdEdldDtcbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5jb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufTtcbmV4cG9ydHMuYml0U2V0ID0gYml0U2V0O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5jb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG5leHBvcnRzLmJpdE1hc2sgPSBiaXRNYXNrO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG5leHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gY3JlYXRlSG1hY0RyYmc7XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGVPYmplY3QiLCJjcmVhdGVIbWFjRHJiZyIsImJpdE1hc2siLCJiaXRTZXQiLCJiaXRHZXQiLCJiaXRMZW4iLCJ1dGY4VG9CeXRlcyIsImVxdWFsQnl0ZXMiLCJjb25jYXRCeXRlcyIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9CeXRlc0JFIiwiYnl0ZXNUb051bWJlckxFIiwiYnl0ZXNUb051bWJlckJFIiwiaGV4VG9CeXRlcyIsImhleFRvTnVtYmVyIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsImJ5dGVzVG9IZXgiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJFcnJvciIsImhleCIsIm51bSIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwicmV2ZXJzZSIsIm4iLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiYjEiLCJiMiIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwicG9zIiwidThuIiwiZGF0YSIsInU4ZnIiLCJhcnIiLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJiIiwicmVzZWVkIiwic2VlZCIsImdlbiIsIm91dCIsInNsIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInVuZGVmaW5lZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./app/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b\nconst mod = __webpack_require__(/*! ./modular.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/modular.js\");\nconst ut = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\nconst curve_js_1 = __webpack_require__(/*! ./curve.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return ut.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0, utils_js_1.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof exports.DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\nexports.weierstrass = weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU; //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUM1SCxvRUFBb0UsR0FDcEUsNERBQTREO0FBQzVELE1BQU1PLE1BQU1DLG1CQUFPQSxDQUFDLGdGQUFjO0FBQ2xDLE1BQU1DLEtBQUtELG1CQUFPQSxDQUFDLDRFQUFZO0FBQy9CLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLFNBQVNJLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPLENBQUMsR0FBR0gsV0FBV0ksYUFBYSxFQUFFRjtJQUMzQ0osR0FBR08sY0FBYyxDQUFDRixNQUFNO1FBQ3BCRyxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHSDtJQUN4QixJQUFJWSxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT2hDLE9BQU9tQyxNQUFN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QUFHa0gsS0FBSyxDQUFDekQsSUFBSSwrQkFBK0I7UUFDdkVBLElBQUl6RCxHQUFHMFMsSUFBSSxDQUFDMVMsR0FBRzZILEdBQUcsQ0FBQ3BFLElBQUlBLEdBQUdtUCxLQUFLLDRCQUE0QjtRQUMzRHBQLElBQUl4RCxHQUFHa1QsR0FBRyxDQUFDMVAsR0FBR2dQLE1BQU0sb0JBQW9CO1FBQ3hDLE9BQU87WUFBRWhQO1lBQUdDO1FBQUU7SUFDbEI7QUFDSjtBQUNBcEYsMkJBQTJCLEdBQUdFLHFCQUM5Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9mZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IGV4cG9ydHMud2VpZXJzdHJhc3MgPSBleHBvcnRzLndlaWVyc3RyYXNzUG9pbnRzID0gZXhwb3J0cy5ERVIgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuY29uc3QgbW9kID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0ID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBjdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBleHBvcnRzLkRFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSB3ZWllcnN0cmFzc1BvaW50cztcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gZXhwb3J0cy5ERVIudG9TaWcoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG5leHBvcnRzLndlaWVyc3RyYXNzID0gd2VpZXJzdHJhc3M7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG5leHBvcnRzLlNXVUZwU3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW87XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiU1dVRnBTcXJ0UmF0aW8iLCJ3ZWllcnN0cmFzcyIsIndlaWVyc3RyYXNzUG9pbnRzIiwiREVSIiwibW9kIiwicmVxdWlyZSIsInV0IiwidXRpbHNfanNfMSIsImN1cnZlX2pzXzEiLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwib3B0cyIsInZhbGlkYXRlQmFzaWMiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3BhcnNlSW50IiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJsZW4iLCJyZXMiLCJzdWJhcnJheSIsImQiLCJsIiwidG9TaWciLCJoZXgiLCJVaW50OEFycmF5IiwiciIsInNCeXRlcyIsInMiLCJyQnl0ZXNMZWZ0IiwiaGV4RnJvbVNpZyIsInNpZyIsInNsaWNlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJoIiwibnVtIiwidG9TdHJpbmciLCJzaGwiLCJyaGwiLCJzbCIsInJsIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiQ1VSVkUiLCJfYyIsInBvaW50IiwiX2lzQ29tcHJlc3NlZCIsInRvQWZmaW5lIiwiY29uY2F0Qnl0ZXMiLCJmcm9tIiwieCIsInkiLCJieXRlcyIsInRhaWwiLCJCWVRFUyIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJ4MiIsInNxciIsIngzIiwibXVsIiwiYWRkIiwiR3kiLCJHeCIsImlzV2l0aGluQ3VydmVPcmRlciIsIm4iLCJhc3NlcnRHRSIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJrZXkiLCJsZW5ndGhzIiwibkJ5dGVMZW5ndGgiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVuc3VyZUJ5dGVzIiwiZXJyb3IiLCJwb2ludFByZWNvbXB1dGVzIiwiTWFwIiwiYXNzZXJ0UHJqUG9pbnQiLCJvdGhlciIsIlBvaW50IiwicHgiLCJweSIsInB6IiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJwIiwiaXMwIiwiaSIsIk9ORSIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsIl9XSU5ET1dfU0laRSIsImRlbGV0ZSIsImxlZnQiLCJyaWdodCIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsIndOQUYiLCJ3bmFmIiwid05BRkNhY2hlZCIsImNvbXAiLCJtdWx0aXBseVVuc2FmZSIsIkkiLCJ1bnNhZmVMYWRkZXIiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsInVuZGVmaW5lZCIsIml6IiwieiIsImludiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiX2JpdHMiLCJuQml0TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibG93UyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaXNWYWxpZEZpZWxkRWxlbWVudCIsIk9SREVSIiwibW9kTiIsImludk4iLCJpbnZlcnQiLCJjYXQiLCJoZWFkIiwieTIiLCJzcXJ0IiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJtZXNzYWdlIiwiaXMiLCJ2IiwiWiIsIm8iLCJjMSIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwicG93IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJ0dnY1IiwiZTEiLCJ5MSIsInZhbGlkYXRlRmllbGQiLCJBIiwiQiIsInR2NiIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/secp256k1.js":
/*!*****************************************************!*\
  !*** ./app/node_modules/@noble/curves/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./app/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\nconst modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/modular.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/weierstrass.js\");\nconst utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/utils.js\");\nconst hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./app/node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./app/node_modules/@noble/curves/_shortw_utils.js\");\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x)=>(0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)(\"signature\", signature, 64);\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const pub = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r)) return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_js_1.numberToBytesBE,\n            bytesToNumberBE: utils_js_1.bytesToNumberBE,\n            taggedHash,\n            mod: modular_js_1.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: sha256_1.sha256\n    }))();\nexports.hashToCurve = (()=>htf.hashToCurve)();\nexports.encodeToCurve = (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUN6RixvRUFBb0UsR0FDcEUsTUFBTU0sV0FBV0MsbUJBQU9BLENBQUMsOEVBQXNCO0FBQy9DLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDRFQUFxQjtBQUM3QyxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyx5RkFBdUI7QUFDcEQsTUFBTUcsbUJBQW1CSCxtQkFBT0EsQ0FBQyxpR0FBMkI7QUFDNUQsTUFBTUksYUFBYUosbUJBQU9BLENBQUMscUZBQXFCO0FBQ2hELE1BQU1LLHFCQUFxQkwsbUJBQU9BLENBQUMscUdBQTZCO0FBQ2hFLE1BQU1NLHFCQUFxQk4sbUJBQU9BLENBQUMsbUZBQW9CO0FBQ3ZELE1BQU1PLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksYUFBYSxDQUFDQyxHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlILEdBQUUsSUFBS0c7QUFDN0M7OztDQUdDLEdBQ0QsU0FBU0MsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlWO0lBQ1Ysa0JBQWtCO0lBQ2xCLE1BQU1XLE1BQU1WLE9BQU8sSUFBSVcsTUFBTVgsT0FBTyxJQUFJWSxPQUFPWixPQUFPLEtBQUthLE9BQU9iLE9BQU87SUFDekUsa0JBQWtCO0lBQ2xCLE1BQU1jLE9BQU9kLE9BQU8sS0FBS2UsT0FBT2YsT0FBTyxLQUFLZ0IsT0FBT2hCLE9BQU87SUFDMUQsTUFBTWlCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1BQU1TLEtBQUssS0FB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SyxTQUFTLENBQUMrRixlQUFlLEVBQUUsQ0FBQ2lFO1FBQ3hHLE1BQU0sRUFBRXZGLENBQUMsRUFBRXZELENBQUMsRUFBRSxHQUFHc0ksT0FBTzlHLEdBQUdtSCxNQUFNLENBQUNHLE9BQU8sQ0FBQyxFQUFFO1FBQzVDLE9BQU9iLE9BQU8xRSxHQUFHdkQ7SUFDckIsR0FBRztRQUNDK0ksS0FBSztRQUNMQyxXQUFXO1FBQ1h6RCxHQUFHL0QsR0FBR3lILEtBQUs7UUFDWHpDLEdBQUc7UUFDSGhFLEdBQUc7UUFDSDBHLFFBQVE7UUFDUkMsTUFBTXBLLFNBQVNxRSxNQUFNO0lBQ3pCLEVBQUM7QUFDRDNFLG1CQUFtQixHQUFHLENBQUMsSUFBTW1LLElBQUloSyxXQUFXO0FBQzVDSCxxQkFBcUIsR0FBRyxDQUFDLElBQU1tSyxJQUFJakssYUFBYSxLQUNoRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanM/NjZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC91dGlscy5qc1wiKTtcbmNvbnN0IGhhc2hfdG9fY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIik7XG5jb25zdCBfc2hvcnR3X3V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hvcnR3X3V0aWxzLmpzXCIpO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9ICgwLCBtb2R1bGFyX2pzXzEucG93MikodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSAoMCwgbW9kdWxhcl9qc18xLkZpZWxkKShzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSAoMCwgX3Nob3J0d191dGlsc19qc18xLmNyZWF0ZUN1cnZlKSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTZfMS5zaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSAoMCwgc2hhMjU2XzEuc2hhMjU2KShVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeCgoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnNjaG5vcnIgPSAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkU6IHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2Q6IG1vZHVsYXJfanNfMS5tb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmlzb2dlbnlNYXApKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nl8xLnNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9ICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW5jb2RlVG9DdXJ2ZSIsImhhc2hUb0N1cnZlIiwic2Nobm9yciIsInNlY3AyNTZrMSIsInNoYTI1Nl8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJtb2R1bGFyX2pzXzEiLCJ3ZWllcnN0cmFzc19qc18xIiwidXRpbHNfanNfMSIsImhhc2hfdG9fY3VydmVfanNfMSIsIl9zaG9ydHdfdXRpbHNfanNfMSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJwb3cyIiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJ0MSIsInQyIiwicm9vdCIsIkZwIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJGaWVsZCIsInVuZGVmaW5lZCIsInNxcnQiLCJjcmVhdGVDdXJ2ZSIsIm4iLCJHeCIsIkd5IiwiaCIsImxvd1MiLCJlbmRvIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiayIsImExIiwiYjEiLCJhMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsIm1vZCIsImsyIiwiazFuZWciLCJrMm5lZyIsInNoYTI1NiIsIl8wbiIsImZlIiwieCIsImdlIiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJjb25jYXRCeXRlcyIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJudW1iZXJUb0J5dGVzQkUiLCJtb2RQIiwibW9kTiIsIlBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiR211bEFkZCIsIlEiLCJCQVNFIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwicCIsImZyb21Qcml2YXRlS2V5Iiwic2NhbGFyIiwiaGFzRXZlblkiLCJieXRlcyIsImxpZnRfeCIsInh4IiwiYXNzZXJ0VmFsaWRpdHkiLCJjaGFsbGVuZ2UiLCJhcmdzIiwiYnl0ZXNUb051bWJlckJFIiwic2Nobm9yckdldFB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwicmFuZG9tQnl0ZXMiLCJtIiwiZW5zdXJlQnl0ZXMiLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwiaXNvTWFwIiwiaXNvZ2VueU1hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsImNyZWF0ZUhhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/_assert.js":
/*!***************************************************!*\
  !*** ./app/node_modules/@noble/hashes/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLFlBQVksR0FBR0EsYUFBYSxHQUFHQSxZQUFZLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3RHLFNBQVNPLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUgsRUFBRSxDQUFDO0FBQ3REO0FBQ0FSLGNBQWMsR0FBR087QUFDakIsU0FBU0QsS0FBS00sQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUQsTUFBTSxDQUFDLHNCQUFzQixFQUFFQyxFQUFFLENBQUM7QUFDcEQ7QUFDQVosWUFBWSxHQUFHTTtBQUNmLFNBQVNELE1BQU1PLENBQUMsRUFBRSxHQUFHQyxPQUFPO0lBQ3hCLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUUsVUFBUyxHQUN4QixNQUFNLElBQUlILE1BQU07SUFDcEIsSUFBSUUsUUFBUUUsTUFBTSxHQUFHLEtBQUssQ0FBQ0YsUUFBUUcsUUFBUSxDQUFDSixFQUFFRyxNQUFNLEdBQ2hELE1BQU0sSUFBSUosTUFBTSxDQUFDLDhCQUE4QixFQUFFRSxRQUFRLGdCQUFnQixFQUFFRCxFQUFFRyxNQUFNLENBQUMsQ0FBQztBQUM3RjtBQUNBZixhQUFhLEdBQUdLO0FBQ2hCLFNBQVNELEtBQUtBLElBQUk7SUFDZCxJQUFJLE9BQU9BLFNBQVMsY0FBYyxPQUFPQSxLQUFLYSxNQUFNLEtBQUssWUFDckQsTUFBTSxJQUFJTixNQUFNO0lBQ3BCSixPQUFPSCxLQUFLYyxTQUFTO0lBQ3JCWCxPQUFPSCxLQUFLZSxRQUFRO0FBQ3hCO0FBQ0FuQixZQUFZLEdBQUdJO0FBQ2YsU0FBU0QsT0FBT2lCLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDMUMsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUlYLE1BQU07SUFDcEIsSUFBSVUsaUJBQWlCRCxTQUFTRyxRQUFRLEVBQ2xDLE1BQU0sSUFBSVosTUFBTTtBQUN4QjtBQUNBWCxjQUFjLEdBQUdHO0FBQ2pCLFNBQVNELE9BQU9zQixHQUFHLEVBQUVKLFFBQVE7SUFDekJmLE1BQU1tQjtJQUNOLE1BQU1DLE1BQU1MLFNBQVNGLFNBQVM7SUFDOUIsSUFBSU0sSUFBSVQsTUFBTSxHQUFHVSxLQUFLO1FBQ2xCLE1BQU0sSUFBSWQsTUFBTSxDQUFDLHNEQUFzRCxFQUFFYyxJQUFJLENBQUM7SUFDbEY7QUFDSjtBQUNBekIsY0FBYyxHQUFHRTtBQUNqQixNQUFNd0IsU0FBUztJQUFFbkI7SUFBUUQ7SUFBTUQ7SUFBT0Q7SUFBTUQ7SUFBUUQ7QUFBTztBQUMzREYsa0JBQWUsR0FBRzBCLFFBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanM/N2MwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvdXRwdXQiLCJleGlzdHMiLCJoYXNoIiwiYnl0ZXMiLCJib29sIiwibnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImIiLCJsZW5ndGhzIiwiVWludDhBcnJheSIsImxlbmd0aCIsImluY2x1ZGVzIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dCIsIm1pbiIsImFzc2VydCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/_sha2.js":
/*!*************************************************!*\
  !*** ./app/node_modules/@noble/hashes/_sha2.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./app/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2; //# sourceMappingURL=_sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBRyxLQUFLO0FBQ3BCLE1BQU1HLGVBQWVDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLG1FQUFZO0FBQ3ZDLHlCQUF5QjtBQUN6QixTQUFTRSxhQUFhQyxJQUFJLEVBQUVDLFVBQVUsRUFBRVAsS0FBSyxFQUFFUSxJQUFJO0lBQy9DLElBQUksT0FBT0YsS0FBS0QsWUFBWSxLQUFLLFlBQzdCLE9BQU9DLEtBQUtELFlBQVksQ0FBQ0UsWUFBWVAsT0FBT1E7SUFDaEQsTUFBTUMsT0FBT0MsT0FBTztJQUNwQixNQUFNQyxXQUFXRCxPQUFPO0lBQ3hCLE1BQU1FLEtBQUtDLE9BQU8sU0FBVUosT0FBUUU7SUFDcEMsTUFBTUcsS0FBS0QsT0FBT2IsUUFBUVc7SUFDMUIsTUFBTUksSUFBSVAsT0FBTyxJQUFJO0lBQ3JCLE1BQU1RLElBQUlSLE9BQU8sSUFBSTtJQUNyQkYsS0FBS1csU0FBUyxDQUFDVixhQUFhUSxHQUFHSCxJQUFJSjtJQUNuQ0YsS0FBS1csU0FBUyxDQUFDVixhQUFhUyxHQUFHRixJQUFJTjtBQUN2QztBQUNBLDZCQUE2QjtBQUM3QixNQUFNUCxhQUFhRyxXQUFXYyxJQUFJO0lBQzlCQyxZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFZCxJQUFJLENBQUU7UUFDOUMsS0FBSztRQUNMLElBQUksQ0FBQ1ksUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ2QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2UsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFB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QU1pQixRQUFRLElBQUksQ0FBQ0MsR0FBRztRQUN0QixJQUFJRixTQUFTQyxNQUFNM0IsTUFBTSxFQUNyQixNQUFNLElBQUl5QixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTS9CLFNBQVMsQ0FBQyxJQUFJOEIsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUV2QztJQUN6QztJQUNBNkMsU0FBUztRQUNMLE1BQU0sRUFBRTFCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUNzQixVQUFVLENBQUNoQjtRQUNoQixNQUFNMkIsTUFBTTNCLE9BQU80QixLQUFLLENBQUMsR0FBR2xDO1FBQzVCLElBQUksQ0FBQ21DLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYQSxNQUFPQSxDQUFBQSxLQUFLLElBQUksSUFBSSxDQUFDdkMsV0FBVyxFQUFDO1FBQ2pDdUMsR0FBR2xCLEdBQUcsSUFBSSxJQUFJLENBQUNZLEdBQUc7UUFDbEIsTUFBTSxFQUFFaEMsUUFBUSxFQUFFTyxNQUFNLEVBQUVILE1BQU0sRUFBRUQsUUFBUSxFQUFFRyxTQUFTLEVBQUVELEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbkVpQyxHQUFHbEMsTUFBTSxHQUFHQTtRQUNaa0MsR0FBR2pDLEdBQUcsR0FBR0E7UUFDVGlDLEdBQUduQyxRQUFRLEdBQUdBO1FBQ2RtQyxHQUFHaEMsU0FBUyxHQUFHQTtRQUNmLElBQUlGLFNBQVNKLFVBQ1RzQyxHQUFHL0IsTUFBTSxDQUFDYSxHQUFHLENBQUNiO1FBQ2xCLE9BQU8rQjtJQUNYO0FBQ0o7QUFDQTNELFlBQVksR0FBR0UsTUFDZixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcz8xYzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEEyID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyID0gU0hBMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNIQTIiLCJfYXNzZXJ0X2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiY3JlYXRlVmlldyIsInVwZGF0ZSIsImRhdGEiLCJleGlzdHMiLCJ0b0J5dGVzIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0Iiwib3V0cHV0IiwiZmlsbCIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/_u64.js":
/*!************************************************!*\
  !*** ./app/node_modules/@noble/hashes/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nexports.split = split;\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l)=>h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsV0FBVyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDalgsTUFBTXdCLGFBQWEsYUFBYSxHQUFHQyxPQUFPLEtBQUssS0FBSztBQUNwRCxNQUFNQyxPQUFPLGFBQWEsR0FBR0QsT0FBTztBQUNwQywrRUFBK0U7QUFDL0UsU0FBU0YsUUFBUUksQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlIO1FBQWFPLEdBQUdELE9BQU8sS0FBTUosT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVLLEdBQUdDLE9BQU8sS0FBTUosT0FBUUYsY0FBYztRQUFHTyxHQUFHRCxPQUFPSCxJQUFJSCxjQUFjO0lBQUU7QUFDcEY7QUFDQXhCLGVBQWUsR0FBR3VCO0FBQ2xCLFNBQVNELE1BQU1VLEdBQUcsRUFBRUosS0FBSyxLQUFLO0lBQzFCLElBQUlLLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVSLENBQUMsRUFBRUUsQ0FBQyxF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QUFPLEtBQU1DLENBQUFBLE9BQU8sS0FBTUcsQ0FBQUEsT0FBTztBQUNqRjlDLGFBQWEsR0FBR0s7QUFDaEIsTUFBTUQsUUFBUSxDQUFDd0MsS0FBS1gsSUFBSVEsSUFBSUksSUFBSUUsS0FBTyxLQUFNTixLQUFLSSxLQUFLRSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDckYvQyxhQUFhLEdBQUdJO0FBQ2hCLE1BQU1GLFFBQVEsQ0FBQ2tDLElBQUlNLElBQUlDLElBQUlHLElBQUlFLEtBQU8sQ0FBQ1osT0FBTyxLQUFNTSxDQUFBQSxPQUFPLEtBQU1DLENBQUFBLE9BQU8sS0FBTUcsQ0FBQUEsT0FBTyxLQUFNRSxDQUFBQSxPQUFPO0FBQ2xHaEQsYUFBYSxHQUFHRTtBQUNoQixNQUFNQyxRQUFRLENBQUN5QyxLQUFLWCxJQUFJUSxJQUFJSSxJQUFJRSxJQUFJRSxLQUFPLEtBQU1SLEtBQUtJLEtBQUtFLEtBQUtFLEtBQU0sT0FBTyxLQUFLLEtBQU0sS0FBTTtBQUM5RmpELGFBQWEsR0FBR0c7QUFDaEIsa0JBQWtCO0FBQ2xCLE1BQU0rQyxNQUFNO0lBQ1IzQjtJQUFTRDtJQUFPRDtJQUNoQkQ7SUFBT0Q7SUFDUEQ7SUFBUUQ7SUFBUUQ7SUFBUUQ7SUFDeEJEO0lBQVNEO0lBQ1REO0lBQVFEO0lBQVFEO0lBQVFEO0lBQ3hCRDtJQUFLRDtJQUFPRDtJQUFPRDtJQUFPRDtJQUFPRDtJQUFPRDtBQUM1QztBQUNBRixrQkFBZSxHQUFHa0QsS0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz81MWMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkM0ggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQgPSBleHBvcnRzLnJvdGxCTCA9IGV4cG9ydHMucm90bEJIID0gZXhwb3J0cy5yb3RsU0wgPSBleHBvcnRzLnJvdGxTSCA9IGV4cG9ydHMucm90cjMyTCA9IGV4cG9ydHMucm90cjMySCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHJTTCA9IGV4cG9ydHMucm90clNIID0gZXhwb3J0cy5zaHJTTCA9IGV4cG9ydHMuc2hyU0ggPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZDVMIiwiYWRkNUgiLCJhZGQ0SCIsImFkZDRMIiwiYWRkM0giLCJhZGQzTCIsImFkZCIsInJvdGxCTCIsInJvdGxCSCIsInJvdGxTTCIsInJvdGxTSCIsInJvdHIzMkwiLCJyb3RyMzJIIiwicm90ckJMIiwicm90ckJIIiwicm90clNMIiwicm90clNIIiwic2hyU0wiLCJzaHJTSCIsInRvQmlnIiwic3BsaXQiLCJmcm9tQmlnIiwiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsImxzdCIsIkFoIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJBbCIsImkiLCJfbCIsInMiLCJfaCIsIkJoIiwiQmwiLCJDbCIsImxvdyIsIkNoIiwiRGwiLCJEaCIsIkVsIiwiRWgiLCJ1NjQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/cryptoNode.js":
/*!******************************************************!*\
  !*** ./app/node_modules/@noble/hashes/cryptoNode.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsb0ZBQW9GO0FBQ3BGLDRCQUE0QjtBQUM1QixpREFBaUQ7QUFDakQsYUFBYTtBQUNiLE1BQU1HLEtBQUtDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ2hDSixjQUFjLEdBQUdHLE1BQU0sT0FBT0EsT0FBTyxZQUFZLGVBQWVBLEtBQUtBLEdBQUdFLFNBQVMsR0FBR0MsV0FDcEYsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcz80YzE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcnlwdG8iLCJuYyIsInJlcXVpcmUiLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/hmac.js":
/*!************************************************!*\
  !*** ./app/node_modules/@noble/hashes/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./app/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.hash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxZQUFZLEdBQUcsS0FBSztBQUNuQyxNQUFNSSxlQUFlQyxtQkFBT0EsQ0FBQyx1RUFBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxtRUFBWTtBQUN2QyxrQkFBa0I7QUFDbEIsTUFBTUYsYUFBYUcsV0FBV0MsSUFBSTtJQUM5QkMsWUFBWUMsSUFBSSxFQUFFQyxJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2hCLElBQUdSLGFBQWFLLElBQUksRUFBRUE7UUFDdkIsTUFBTUksTUFBTSxDQUFDLEdBQUdQLFdBQVdRLE9BQU8sRUFBRUo7UUFDcEMsSUFBSSxDQUFDSyxLQUFLLEdBQUdOLEtBQUtPLE1BQU07UUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDRSxNQUFNLEtBQUssWUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxRQUFRO1FBQ25DLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO1FBQ3JDLE1BQU1ELFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU1FLE1BQU0sSUFBSUMsV0FBV0g7UUFDM0Isd0NBQXdDO1FBQ3hDRSxJQUFJRSxHQUFHLENBQUNWLElBQUlXLE1BQU0sR0FBR0wsV0FBV1YsS0FBS08sTUFBTSxHQUFHQyxNQUFNLENBQUNKLEtBQUtZLE1BQU0sS0FBS1o7UUFDckUsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDWCxLQUFLLENBQUNFLE1BQU0sQ0FBQ0k7UUFDbEIsbUhBQW1IO1FBQ25ILElBQUksQ0FBQ00sS0FBSyxHQUFHbEIsS0FBS08sTUFBTTtRQUN4Qix1Q0FBdUM7UUFDdkMsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJLE9BQU87UUFDckIsSUFBSSxDQUFDQyxLQUFLLENBQUNWLE1BQU0sQ0FBQ0k7UUFDbEJBLElBQUlPLElBQUksQ0FBQztJQUNiO0lBQ0FYLE9BQU9ZLEdBQUcsRUFBRTtRQUNQLElBQUd6QixhQUFhMEIsTUFBTSxFQUFFLElBQUk7UUFDN0IsSUFBSSxDQUFDZixLQUFLLENBQUNFLE1BQU0sQ0FBQ1k7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUUsV0FBV0MsR0FBRyxFQUFFO1FBQ1gsSUFBRzVCLGFBQWEwQixNQUFNLEVBQUUsSUFBSTtRQUM1QixJQUFHMUIsYUFBYTZCLEtBQUssRUFBRUQsS0FBSyxJQUFJLENBQUNaLFNBQVM7UUFDM0MsSUFBSSxDQUFDVCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDSSxLQUFLLENBQUNnQixVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0wsS0FBSyxDQUFDVixNQUFNLENBQUNlO1FBQ2xCLElBQUksQ0FBQ0wsS0FBSyxDQUFDSSxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0UsT0FBTztJQUNoQjtJQUNBVCxTQUFTO1FBQ0wsTUFBTU8sTUFBTSxJQUFJVixXQUFXLElBQUksQ0FBQ0ssS0FBSyxDQUFDUCxTQUFTO1FBQy9DLElBQUksQ0FBQ1csVUFBVSxDQUFDQztRQUNoQixPQUFPQTtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYLG1HQUFtRztRQUNuR0EsTUFBT0EsQ0FBQUEsS0FBS3RDLE9BQU9rQixNQUFNLENBQUNsQixPQUFPdUMsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFVixLQUFLLEVBQUVaLEtBQUssRUFBRUosUUFBUSxFQUFFQyxTQUFTLEVBQUVPLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RWdCLEtBQUtBO1FBQ0xBLEdBQUd6QixRQUFRLEdBQUdBO1FBQ2R5QixHQUFHeEIsU0FBUyxHQUFHQTtRQUNmd0IsR0FBR2pCLFFBQVEsR0FBR0E7UUFDZGlCLEdBQUdoQixTQUFTLEdBQUdBO1FBQ2ZnQixHQUFHVCxLQUFLLEdBQUdBLE1BQU1RLFVBQVUsQ0FBQ0MsR0FBR1QsS0FBSztRQUNwQ1MsR0FBR3JCLEtBQUssR0FBR0EsTUFBTW9CLFVBQVUsQ0FBQ0MsR0FBR3JCLEtBQUs7UUFDcEMsT0FBT3FCO0lBQ1g7SUFDQUYsVUFBVTtRQUNOLElBQUksQ0FBQ3RCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNlLEtBQUssQ0FBQ08sT0FBTztRQUNsQixJQUFJLENBQUNuQixLQUFLLENBQUNtQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQWxDLFlBQVksR0FBR0c7QUFDZjs7Ozs7Q0FLQyxHQUNELE1BQU1ELE9BQU8sQ0FBQ08sTUFBTUksS0FBS3lCLFVBQVksSUFBSW5DLEtBQUtNLE1BQU1JLEtBQUtJLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU07QUFDL0V6QixZQUFZLEdBQUdFO0FBQ2ZGLG1CQUFtQixHQUFHLENBQUNTLE1BQU1JLE1BQVEsSUFBSVYsS0FBS00sTUFBTUksTUFDcEQsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcz83MmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuaGFzaCkoaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhtYWMiLCJITUFDIiwiX2Fzc2VydF9qc18xIiwicmVxdWlyZSIsInV0aWxzX2pzXzEiLCJIYXNoIiwiY29uc3RydWN0b3IiLCJoYXNoIiwiX2tleSIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwia2V5IiwidG9CeXRlcyIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJmaWxsIiwiYnVmIiwiZXhpc3RzIiwiZGlnZXN0SW50byIsIm91dCIsImJ5dGVzIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImdldFByb3RvdHlwZU9mIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/sha256.js":
/*!**************************************************!*\
  !*** ./app/node_modules/@noble/hashes/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./app/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3ZDLE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLG1FQUFZO0FBQ3ZDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLG1FQUFZO0FBQ3ZDLGdFQUFnRTtBQUNoRSwwREFBMEQ7QUFDMUQsb0JBQW9CO0FBQ3BCLE1BQU1FLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNLENBQUNELElBQUlFO0FBQ3pDLG9EQUFvRDtBQUNwRCxNQUFNQyxNQUFNLENBQUNILEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTUQsSUFBSUUsSUFBTUQsSUFBSUM7QUFDbEQsbUJBQW1CO0FBQ25CLHlGQUF5RjtBQUN6RixrQkFBa0I7QUFDbEIsTUFBTUUsV0FBVyxhQUFhLEdBQUcsSUFBSUMsWUFBWTtJQUM3QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCx5R0FBeUc7QUFDekcsa0JBQWtCO0FBQ2xCLE1BQU1DLEtBQUssYUFBYSxHQUFHLElBQUlELFlBQVk7SUFDdkM7SUFB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QyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNFLEdBQUcsQ0FBQ1QsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDbEM7SUFDQWlCLGFBQWE7UUFDVDVCLFNBQVM2QixJQUFJLENBQUM7SUFDbEI7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQzlCLElBQUksQ0FBQ2tCLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDO0lBQ3JCO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsTUFBTUcsZUFBZS9CO0lBQ2pCRSxhQUFjO1FBQ1YsS0FBSztRQUNMLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNzQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNEaEQsY0FBYyxHQUFHLENBQUMsR0FBR00sV0FBVzJDLGVBQWUsRUFBRSxJQUFNLElBQUlqQztBQUMzRGhCLGNBQWMsR0FBRyxDQUFDLEdBQUdNLFdBQVcyQyxlQUFlLEVBQUUsSUFBTSxJQUFJRixXQUMzRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanM/MzkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hhMjI0Iiwic2hhMjU2IiwiX3NoYTJfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsIklWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJTSEEyIiwiY29uc3RydWN0b3IiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsImdldCIsInNldCIsInByb2Nlc3MiLCJ2aWV3Iiwib2Zmc2V0IiwiaSIsImdldFVpbnQzMiIsIlcxNSIsIlcyIiwiczAiLCJyb3RyIiwiczEiLCJzaWdtYTEiLCJUMSIsInNpZ21hMCIsIlQyIiwicm91bmRDbGVhbiIsImZpbGwiLCJkZXN0cm95IiwiYnVmZmVyIiwiU0hBMjI0Iiwib3V0cHV0TGVuIiwid3JhcENvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/sha3.js":
/*!************************************************!*\
  !*** ./app/node_modules/@noble/hashes/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./app/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./app/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/hashes/utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, _assert_js_1.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, _assert_js_1.exists)(this, false);\n        (0, _assert_js_1.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, _assert_js_1.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, _assert_js_1.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ exports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ exports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDOU8sTUFBTWMsZUFBZUMsbUJBQU9BLENBQUMsdUVBQWM7QUFDM0MsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsaUVBQVc7QUFDckMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsbUVBQVk7QUFDdkMsb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDRyxTQUFTQyxXQUFXQyxXQUFXLEdBQUc7SUFBQyxFQUFFO0lBQUUsRUFBRTtJQUFFLEVBQUU7Q0FBQztBQUNyRCxNQUFNQyxNQUFNLGFBQWEsR0FBR0MsT0FBTztBQUNuQyxNQUFNQyxNQUFNLGFBQWEsR0FBR0QsT0FBTztBQUNuQyxNQUFNRSxNQUFNLGFBQWEsR0FBR0YsT0FBTztBQUNuQyxNQUFNRyxNQUFNLGFBQWEsR0FBR0gsT0FBTztBQUNuQyxNQUFNSSxRQUFRLGFBQWEsR0FBR0osT0FBTztBQUNyQyxNQUFNSyxTQUFTLGFBQWEsR0FBR0wsT0FBTztBQUN0QyxJQUFLLElBQUlNLFFBQVEsR0FBR0MsSUFBSU4sS0FBS08sSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNiLFFBQVFjLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYlgsVUFBVWEsSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FBQUEsUUFBUSxLQUFNLElBQUs7SUFDbkQsT0FBTztJQUNQLElBQUlLLElBQUlaO0lBQ1IsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN4QkwsSUFBSSxDQUFDLEtBQU1OLE1BQVEsQ0FBQ00sS0FBS0osR0FBRSxJQUFLRSxNQUFNLElBQUtEO1FBQzNDLElBQUlHLElBQUlMLEtBQ0pTLEtBQUtWLE9BQVEsQ0FBQ0EsT0FBTyxhQUFhLEdBQUdELE9BQU9ZLEVBQUMsSUFBS1g7SUFDMUQ7SUFDQUgsV0FBV1ksSUFBSSxDQUFDQztBQUNwQjtBQUNBLE1BQU0sQ0FBQ0UsYUFBYUMsWUFBWSxHQUFtQixhQUFILEdBQUksSUFBR3BCLFVBQVVxQixLQUFLLEVBQUVqQixZQUFZO0FBQ3BGLG9DQUFvQztBQUNwQyxNQUFNa0IsUUFBUSxDQUFDQyxHQUFHQyxHQUFHQyxJQUFPQSxJQUFJLEtBQUssQ0FBQyxHQUFHekIsVUFBVTBCLE1BQU0sRUFBRUgsR0FBR0MsR0FBR0MsS0FBSyxDQUFDLEdBQUd6QixVQUFVMkIsTUFBTSxFQUFFSixHQUFHQyxHQUFHQztBQUNsRyxNQUFNRyxRQUFRLENBQUNMLEdBQUdDLEdBQUdDLElBQU9BLElBQUksS0FBSyxDQUFDLEdBQUd6QixVQUFVNkIsTUFBTSxFQUFFTixHQUFHQyxHQUFHQyxLQUFLLENBQUMsR0FBR3pCLFVBQVU4QixNQUFNLEVBQUVQLEdBQUdDLEdBQUdDO0FBQ2xHLHNEQUFzRDtBQUN0RCxTQUFTNUIsUUFBUTRCLENBQUMsRUFBRU0sU0FBUyxFQUFFO0lBQzNCLE1BQU1DLElBQUksSUFBSUMsWUFBWSxJQUFJO0lBQzlCLDhGQUE4RjtJQUM5RixJQUFLLElBQUlyQixRQUFRLEtBQUttQixRQUFRbkIsUUFBUSxJQUFJQSxRQUFTO1FBQy9DLFVBQVU7UUFDVixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUNwQmtCLENBQUMsQ0FBQ2xCLEVBQUUsR0FBR1csQ0FBQyxDQUFDWCxFQUFFLEdBQUdXLENBQUMsQ0FBQ1gsSUFBSSxHQUFHLEdBQUdXLENBQUMsQ0FBQ1gsSUFBSSxHQUFHLEdBQUdXLENBQUMsQ0FBQ1gsSUFBSSxHQUFHLEdBQUdXLENBQUMsQ0FBQ1gsSUFBSSxHQUFHO1FBQy9ELElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztZQUM1QixNQUFNb0IsT0FBTyxDQUFDcEIsSUFBSSxLQUFLO1lBQ3ZCLE1BQU1xQixPQUFPLENBQUNyQixJQUFJLEtBQUs7WUFDdkIsTUFBTXNCLEtBQUtKLENBQUMsQ0FBQ0csS0FBSztZQUNsQixNQUFNRSxLQUFLTCxDQUFDLENBQUNHLE9BQU8sRUFBRTtZQUN0QixNQUFNRyxLQUFLaEIsTUFBTWMsSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLEtBQUs7WUFDckMsTUFBTUssS0FBS1gsTUFBTVEsSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLE9BQU8sRUFBRTtZQUN6QyxJQUFLLElBQUluQixJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxHQUFJO2dCQUM3QlUsQ0FBQyxDQUFDWCxJQUFJQyxFQUFFLElBQUl1QjtnQkFDWmIsQ0FBQyxDQUFDWCxJQUFJQyxJQUFJLEVBQUUsSUFBSXdCO1lBQ3BCO1FBQ0o7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUMsT0FBT2YsQ0FBQyxDQUFDLEVBQUU7UUFDZixJQUFJZ0IsT0FBT2hCLENBQUMsQ0FBQyxFQUFFO1FBQ2YsSUFBSyxJQUFJUixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztZQUN6QixNQUFNeUIsUUFBUXZDLFNBQVMsQ0FBQ2MsRUFBRTtZQUMxQixNQUFNcUIsS0FBS2hCLE1BQU1rQixNQUFNQyxNQUFNQztZQUM3QixNQUFNSCxLQUFLWCxNQUFNWSxNQUFNQyxNQUFNQztZQUM3QixNQUFNQyxLQUFLekMsT0FBTyxDQUFDZSxFQUFFO1lBQ3JCdUIsT0FBT2YsQ0FBQyxDQUFDa0IsR0FBRztZQUNaRixPQUFPaEIsQ0FBQyxDQUFDa0IsS0FBSyxFQUFFO1lBQ2hCbEIsQ0FBQyxDQUFDa0IsR0FBRyxHQUFHTDtZQUNSYixDQUFDLENBQUNrQixLQUFLLEVBQUUsR0FBR0o7UUFDaEI7UUFDQSxVQUFVO1FBQ1YsSUFBSyxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssR0FBSTtZQUM3QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUNwQmtCLENBQUMsQ0FBQ2xCLEVBQUUsR0FBR1csQ0FBQyxDQUFDVixJQUFJRCxFQUFFO1lBQ25CLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQ3BCVyxDQUFDLENBQUNWLElBQUlELEVBQUUsSUFBSSxDQUFDa0IsQ0FBQyxDQUFDLENBQUNsQixJQUFJLEtBQUssR0FBRyxHQUFHa0IsQ0FBQyxDQUFDLENBQUNsQixJQUFJLEtBQUssR0FBRztRQUN0RDtRQUNBLFdBQVc7UUFDWFcsQ0FBQyxDQUFDLEVBQUUsSUFBSU4sV0FBVyxDQUFDUCxNQUFNO1FBQzFCYSxDQUFDLENBQUMsRUFBRSxJQUFJTCxXQUFXLENBQUNSLE1BQU07SUFDOUI7SUFDQW9CLEVBQUVZLElBQUksQ0FBQztBQUNYO0FBQ0E1RCxlQUFlLEdBQUdhO0FBQ2xCLE1BQU1ELGVBQWVLLFdBQVc0QyxJQUFJO0lBQ2hDLDJEQUEyRDtJQUMzREMsWUFBWUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxLQUFLLEVBQUVuQixTQUFTLEVBQUUsQ0FBRTtRQUNyRSxLQUFLO1FBQ0wsSUFBSSxDQUFDZ0IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ25CLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNvQixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLG1DQUFtQztRQUNsQyxJQUFHeEQsYUFBYXlELE1BQU0sRUFBRU47UUFDekIsdURBQXVEO1FBQ3ZELElBQUksS0FBSyxJQUFJLENBQUNGLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsSUFBSSxLQUN2QyxNQUFNLElBQUlTLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSUMsV0FBVztRQUM1QixJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLEdBQUcxRCxXQUFXMkQsR0FBRyxFQUFFLElBQUksQ0FBQ0gsS0FBSztJQUNqRDtJQUNBSSxTQUFTO1FBQ0xoRSxRQUFRLElBQUksQ0FBQzhELE9BQU8sRUFBRSxJQUFJLENBQUM1QixNQUFNO1FBQ2pDLElBQUksQ0FBQ3FCLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0QsR0FBRyxHQUFHO0lBQ2Y7SUFDQVcsT0FBT0MsSUFBSSxFQUFFO1FBQ1IsSUFBR2pFLGFBQWFrRSxNQUFNLEVBQUUsSUFBSTtRQUM3QixNQUFNLEVBQUVqQixRQUFRLEVBQUVVLEtBQUssRUFBRSxHQUFHLElBQUk7UUFDaENNLE9BQU8sQ0FBQyxHQUFHOUQsV0FBV2dFLE9BQU8sRUFBRUY7UUFDL0IsTUFBTUcsTUFBTUgsS0FBS0ksTUFBTTtRQUN2QixJQUFLLElBQUloQixNQUFNLEdBQUdBLE1BQU1lLEtBQU07WUFDMUIsTUFBTUUsT0FBT0MsS0FBS0MsR0FBRyxDQUFDdkIsV0FBVyxJQUFJLENBQUNJLEdBQUcsRUFBRWUsTUFBTWY7WUFDakQsSUFBSyxJQUFJb0IsSUFBSSxHQUFHQSxJQUFJSCxNQUFNRyxJQUN0QmQsS0FBSyxDQUFDLElBQUksQ0FBQ04sR0FBRyxHQUFHLElBQUlZLElBQUksQ0FBQ1osTUFBTTtZQUNwQyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxLQUFLSixVQUNiLElBQUksQ0FBQ2MsTUFBTTtRQUNuQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FXLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ25CLFFBQVEsRUFDYjtRQUNKLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1FBQ2hCLE1BQU0sRUFBRUksS0FBSyxFQUFFVCxNQUFNLEVBQUVHLEdBQUcsRUFBRUosUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUM3QyxpQkFBaUI7UUFDakJVLEtBQUssQ0FBQ04sSUFBSSxJQUFJSDtRQUNkLElBQUksQ0FBQ0EsU0FBUyxJQUFHLE1BQU8sS0FBS0csUUFBUUosV0FBVyxHQUM1QyxJQUFJLENBQUNjLE1BQU07UUFDZkosS0FBSyxDQUFDVixXQUFXLEVBQUUsSUFBSTtRQUN2QixJQUFJLENBQUNjLE1BQU07SUFDZjtJQUNBWSxVQUFVQyxHQUFHLEVBQUU7UUFDVixJQUFHNUUsYUFBYWtFLE1BQU0sRUFBRSxJQUFJLEVBQUU7UUFDOUIsSUFBR2xFLGFBQWE2RSxLQUFLLEVBQUVEO1FBQ3hCLElBQUksQ0FBQ0YsTUFBTTtRQUNYLE1BQU1JLFlBQVksSUFBSSxDQUFDbkIsS0FBSztRQUM1QixNQUFNLEVBQUVWLFFBQVEsRUFBRSxHQUFHLElBQUk7UUFDekIsSUFBSyxJQUFJSSxNQUFNLEdBQUdlLE1BQU1RLElBQUlQLE1BQU0sRUFBRWhCLE1BQU1lLEtBQU07WUFDNUMsSUFBSSxJQUFJLENBQUNkLE1BQU0sSUFBSUwsVUFDZixJQUFJLENBQUNjLE1BQU07WUFDZixNQUFNTyxPQUFPQyxLQUFLQyxHQUFHLENBQUN2QixXQUFXLElBQUksQ0FBQ0ssTUFBTSxFQUFFYyxNQUFNZjtZQUNwRHVCLElBQUlHLEdBQUcsQ0FBQ0QsVUFBVUUsUUFBUSxDQUFDLElBQUksQ0FBQzFCLE1BQU0sRUFBRSxJQUFJLENBQUNBLE1BQU0sR0FBR2dCLE9BQU9qQjtZQUM3RCxJQUFJLENBQUNDLE1BQU0sSUFBSWdCO1lBQ2ZqQixPQUFPaUI7UUFDWDtRQUNBLE9BQU9NO0lBQ1g7SUFDQUssUUFBUUwsR0FBRyxFQUFFO1FBQ1Qsa0ZBQWtGO1FBQ2xGLElBQUksQ0FBQyxJQUFJLENBQUN4QixTQUFTLEVBQ2YsTUFBTSxJQUFJTSxNQUFNO1FBQ3BCLE9BQU8sSUFBSSxDQUFDaUIsU0FBUyxDQUFDQztJQUMxQjtJQUNBTSxJQUFJTCxLQUFLLEVBQUU7UUFDTixJQUFHN0UsYUFBYXlELE1BQU0sRUFBRW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDSSxPQUFPLENBQUMsSUFBSXJCLFdBQVdpQjtJQUN2QztJQUNBTSxXQUFXUCxHQUFHLEVBQUU7UUFDWCxJQUFHNUUsYUFBYW9GLE1BQU0sRUFBRVIsS0FBSyxJQUFJO1FBQ2xDLElBQUksSUFBSSxDQUFDckIsUUFBUSxFQUNiLE1BQU0sSUFBSUcsTUFBTTtRQUNwQixJQUFJLENBQUNpQixTQUFTLENBQUNDO1FBQ2YsSUFBSSxDQUFDUyxPQUFPO1FBQ1osT0FBT1Q7SUFDWDtJQUNBVSxTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUNILFVBQVUsQ0FBQyxJQUFJdkIsV0FBVyxJQUFJLENBQUNULFNBQVM7SUFDeEQ7SUFDQWtDLFVBQVU7UUFDTixJQUFJLENBQUM3QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRyxLQUFLLENBQUNiLElBQUksQ0FBQztJQUNwQjtJQUNBeUMsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsTUFBTSxFQUFFdkMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRWxCLE1BQU0sRUFBRW1CLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDL0RvQyxNQUFPQSxDQUFBQSxLQUFLLElBQUkxRixPQUFPbUQsVUFBVUMsUUFBUUMsV0FBV0MsV0FBV25CLE9BQU07UUFDckV1RCxHQUFHM0IsT0FBTyxDQUFDa0IsR0FBRyxDQUFDLElBQUksQ0FBQ2xCLE9BQU87UUFDM0IyQixHQUFHbkMsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRztRQUNqQm1DLEdBQUdsQyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCa0MsR0FBR2pDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDM0JpQyxHQUFHdkQsTUFBTSxHQUFHQTtRQUNaLDhCQUE4QjtRQUM5QnVELEdBQUd0QyxNQUFNLEdBQUdBO1FBQ1pzQyxHQUFHckMsU0FBUyxHQUFHQTtRQUNmcUMsR0FBR3BDLFNBQVMsR0FBR0E7UUFDZm9DLEdBQUdoQyxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO1FBQzdCLE9BQU9nQztJQUNYO0FBQ0o7QUFDQXRHLGNBQWMsR0FBR1k7QUFDakIsTUFBTTJGLE1BQU0sQ0FBQ3ZDLFFBQVFELFVBQVVFLFlBQWMsQ0FBQyxHQUFHaEQsV0FBV3VGLGVBQWUsRUFBRSxJQUFNLElBQUk1RixPQUFPbUQsVUFBVUMsUUFBUUM7QUFDaEhqRSxnQkFBZ0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEM7OztDQUdDLEdBQ0R2RyxnQkFBZ0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEN2RyxnQkFBZ0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEN2RyxnQkFBZ0IsR0FBR3VHLElBQUksTUFBTSxJQUFJLE1BQU07QUFDdkN2RyxrQkFBa0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUM7OztDQUdDLEdBQ0R2RyxrQkFBa0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUN2RyxrQkFBa0IsR0FBR3VHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUN2RyxrQkFBa0IsR0FBR3VHLElBQUksTUFBTSxJQUFJLE1BQU07QUFDekMsTUFBTUUsV0FBVyxDQUFDekMsUUFBUUQsVUFBVUUsWUFBYyxDQUFDLEdBQUdoRCxXQUFXeUYsMEJBQTBCLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDLENBQUMsR0FBSyxJQUFJL0YsT0FBT21ELFVBQVVDLFFBQVEyQyxLQUFLQyxLQUFLLEtBQUtDLFlBQVk1QyxZQUFZMEMsS0FBS0MsS0FBSyxFQUFFO0FBQzVMNUcsZ0JBQWdCLEdBQUd5RyxTQUFTLE1BQU0sS0FBSyxNQUFNO0FBQzdDekcsZ0JBQWdCLEdBQUd5RyxTQUFTLE1BQU0sS0FBSyxNQUFNLElBQzdDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanM/ZmVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBleHBvcnRzLnNoYWtlMTI4ID0gZXhwb3J0cy5rZWNjYWtfNTEyID0gZXhwb3J0cy5rZWNjYWtfMzg0ID0gZXhwb3J0cy5rZWNjYWtfMjU2ID0gZXhwb3J0cy5rZWNjYWtfMjI0ID0gZXhwb3J0cy5zaGEzXzUxMiA9IGV4cG9ydHMuc2hhM18zODQgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5zaGEzXzIyNCA9IGV4cG9ydHMuS2VjY2FrID0gZXhwb3J0cy5rZWNjYWtQID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IF91NjRfanNfMSA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gKDAsIF91NjRfanNfMS5zcGxpdCkoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyAoMCwgX3U2NF9qc18xLnJvdGxCSCkoaCwgbCwgcykgOiAoMCwgX3U2NF9qc18xLnJvdGxTSCkoaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X2pzXzEucm90bEJMKShoLCBsLCBzKSA6ICgwLCBfdTY0X2pzXzEucm90bFNMKShoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydHMua2VjY2FrUCA9IGtlY2Nha1A7XG5jbGFzcyBLZWNjYWsgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5vdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLktlY2NhayA9IEtlY2NhaztcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydHMuc2hhM18yMjQgPSBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLnNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLnNoYTNfNTEyID0gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzIyNCA9IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzM4NCA9IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0cy5zaGFrZTEyOCA9IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hha2UyNTYiLCJzaGFrZTEyOCIsImtlY2Nha181MTIiLCJrZWNjYWtfMzg0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18yMjQiLCJzaGEzXzUxMiIsInNoYTNfMzg0Iiwic2hhM18yNTYiLCJzaGEzXzIyNCIsIktlY2NhayIsImtlY2Nha1AiLCJfYXNzZXJ0X2pzXzEiLCJyZXF1aXJlIiwiX3U2NF9qc18xIiwidXRpbHNfanNfMSIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJzcGxpdCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEJIIiwicm90bFNIIiwicm90bEwiLCJyb3RsQkwiLCJyb3RsU0wiLCJyb3VuZHMiLCJCIiwiVWludDMyQXJyYXkiLCJpZHgxIiwiaWR4MCIsIkIwIiwiQjEiLCJUaCIsIlRsIiwiY3VySCIsImN1ckwiLCJzaGlmdCIsIlBJIiwiZmlsbCIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJudW1iZXIiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJ1MzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwiZXhpc3RzIiwidG9CeXRlcyIsImxlbiIsImxlbmd0aCIsInRha2UiLCJNYXRoIiwibWluIiwiaSIsImZpbmlzaCIsIndyaXRlSW50byIsIm91dCIsImJ5dGVzIiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiZGlnZXN0SW50byIsIm91dHB1dCIsImRlc3Ryb3kiLCJkaWdlc3QiLCJfY2xvbmVJbnRvIiwidG8iLCJnZW4iLCJ3cmFwQ29uc3RydWN0b3IiLCJnZW5TaGFrZSIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwib3B0cyIsImRrTGVuIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/utils.js":
/*!*************************************************!*\
  !*** ./app/node_modules/@noble/hashes/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./app/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\nexports.randomBytes = randomBytes; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvRUFBb0UsR0FDcEVBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0Esa0NBQWtDLEdBQUdBLCtCQUErQixHQUFHQSx1QkFBdUIsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0EsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0Esa0JBQWtCLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDNVgsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCw4REFBOEQ7QUFDOUQsTUFBTW9CLFdBQVdDLG1CQUFPQSxDQUFDLGtGQUFzQjtBQUMvQyxNQUFNQyxNQUFNLENBQUNDLElBQU1BLGFBQWFDO0FBQ2hDLCtCQUErQjtBQUMvQixNQUFNTCxLQUFLLENBQUNNLE1BQVEsSUFBSUQsV0FBV0MsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVU7QUFDN0U1QixVQUFVLEdBQUdtQjtBQUNiLE1BQU1ELE1BQU0sQ0FBQ08sTUFBUSxJQUFJSSxZQUFZSixJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUcsS0FBS0MsS0FBSyxDQUFDTixJQUFJRyxVQUFVLEdBQUc7QUFDN0Y1QixXQUFXLEdBQUdrQjtBQUNkLHFCQUFxQjtBQUNyQixNQUFNRCxhQUFhLENBQUNRLE1BQVEsSUFBSU8sU0FBU1AsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVU7QUFDbkY1QixrQkFBa0IsR0FBR2lCO0FBQ3JCLCtEQUErRDtB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d2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzPzRiZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyYW5kb21CeXRlcyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3IiLCJjaGVja09wdHMiLCJIYXNoIiwiY29uY2F0Qnl0ZXMiLCJ0b0J5dGVzIiwidXRmOFRvQnl0ZXMiLCJhc3luY0xvb3AiLCJuZXh0VGljayIsImhleFRvQnl0ZXMiLCJieXRlc1RvSGV4IiwiaXNMRSIsInJvdHIiLCJjcmVhdGVWaWV3IiwidTMyIiwidTgiLCJjcnlwdG9fMSIsInJlcXVpcmUiLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJEYXRhVmlldyIsIndvcmQiLCJzaGlmdCIsIkVycm9yIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlcyIsImhleCIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkYXRhIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJjbG9uZSIsIl9jbG9uZUludG8iLCJ0b1N0ciIsImRlZmF1bHRzIiwib3B0cyIsInVuZGVmaW5lZCIsImNhbGwiLCJtZXJnZWQiLCJhc3NpZ24iLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJieXRlc0xlbmd0aCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/curves/esm/abstract/utils.js":
/*!**************************************************************!*\
  !*** ./app/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsMEVBQTBFO0FBQzFFLDhEQUE4RDtBQUM5RCwrRUFBK0U7QUFDL0UsdUNBQXVDO0FBQ3ZDLE1BQU1BLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsTUFBTUMsUUFBUSxhQUFhLEdBQUdDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0Y7O0NBRUMsR0FDTSxTQUFTQyxXQUFXQyxLQUFLO0lBQzVCLElBQUksQ0FBQ1osSUFBSVksUUFDTCxNQUFNLElBQUlDLE1BQU07SUFDcEIsb0NBQW9DO0lBQ3BDLElBQUlDLE1BQU07SUFDVixJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSUksTUFBTU4sTUFBTSxFQUFFRSxJQUFLO1FBQ25DTSxPQUFPWCxLQUFLLENBQUNTLEtBQUssQ0FBQ0osRUFBRSxDQUFDO0lBQzFCO0lBQ0EsT0FBT007QUFDWDtBQUNPLFNBQVNDLG9CQUFvQkMsR0FBRztJQUNuQyxNQUFNRixNQUFNRSxJQUFJUCxRQUFRLENBQUM7SUFDekIsT0FBT0ssSUFBSVIsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUVRLElBQUksQ0FBQyxHQUFHQTtBQUN4QztBQUNPLFNBQVNHLFlBQVlILEdBQUc7SUFDM0IsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJRCxNQUFNLDhCQUE4QixPQUFPQztJQUN6RCxhQUFhO0lBQ2IsT0FBT2pCLE9BQU9pQixRQUFRLEtBQUssTUFBTSxDQUFDLEVBQUUsRUFB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SUFBSSxPQUFPRSxhQUFhLFlBQ3BCLE1BQU0sSUFBSTdGLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTJGLEtBQUssb0JBQW9CLENBQUM7UUFDcEUsTUFBTWxCLE1BQU1RLE1BQU0sQ0FBQ1MsVUFBVTtRQUM3QixJQUFJRSxjQUFjbkIsUUFBUUgsV0FDdEI7UUFDSixJQUFJLENBQUN1QixTQUFTcEIsS0FBS1EsU0FBUztZQUN4QixNQUFNLElBQUlqRixNQUFNLENBQUMsY0FBYyxFQUFFOEYsT0FBT0osV0FBVyxDQUFDLEVBQUVqQixJQUFJLEVBQUUsRUFBRSxPQUFPQSxJQUFJLFlBQVksRUFBRWtCLEtBQUssQ0FBQztRQUNqRztJQUNKO0lBQ0EsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSUksT0FBT0MsT0FBTyxDQUFDVCxZQUMzQ0UsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJSSxPQUFPQyxPQUFPLENBQUNSLGVBQzNDQyxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLE9BQU9WO0FBQ1gsRUFDQSxzQkFBc0I7Q0FDdEIsdUVBQXVFO0NBQ3ZFLGdGQUFnRjtDQUNoRiw0QkFBNEI7Q0FDNUIsMkRBQTJEO0NBQzNELHFFQUFxRTtDQUNyRSwrREFBK0Q7Q0FDL0QsNERBQTREO0NBQzVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcz84MzAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodThhKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsInU4YSIsImEiLCJVaW50OEFycmF5IiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJFcnJvciIsImhleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXhUb051bWJlciIsImhleFRvQnl0ZXMiLCJsZW4iLCJhcnJheSIsImoiLCJoZXhCeXRlIiwic2xpY2UiLCJieXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJpc05hTiIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsInJldmVyc2UiLCJudW1iZXJUb0J5dGVzQkUiLCJuIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJlcXVhbEJ5dGVzIiwiYjEiLCJiMiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJiaXRMZW4iLCJiaXRHZXQiLCJwb3MiLCJiaXRTZXQiLCJ2YWx1ZSIsImJpdE1hc2siLCJ1OG4iLCJkYXRhIiwidThmciIsImFyciIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidiIsImsiLCJyZXNldCIsImZpbGwiLCJoIiwiYiIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInB1c2giLCJnZW5VbnRpbCIsInByZWQiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0b3JGbnMiLCJiaWdpbnQiLCJ2YWwiLCJmdW5jdGlvbiIsImJvb2xlYW4iLCJzdHJpbmciLCJzdHJpbmdPclVpbnQ4QXJyYXkiLCJpc1NhZmVJbnRlZ2VyIiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/esm/_assert.js":
/*!*******************************************************!*\
  !*** ./app/node_modules/@noble/hashes/esm/_assert.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBQVNBLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUgsRUFBRSxDQUFDO0FBQ3REO0FBQ0EsU0FBU0ksS0FBS0MsQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSxDQUFDLHNCQUFzQixFQUFFRSxFQUFFLENBQUM7QUFDcEQ7QUFDQSxTQUFTQyxNQUFNRCxDQUFDLEVBQUUsR0FBR0UsT0FBTztJQUN4QixJQUFJLENBQUVGLENBQUFBLGFBQWFHLFVBQVMsR0FDeEIsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCLElBQUlJLFFBQVFFLE1BQU0sR0FBRyxLQUFLLENBQUNGLFFBQVFHLFFBQVEsQ0FBQ0wsRUFBRUksTUFBTSxHQUNoRCxNQUFNLElBQUlOLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRUksUUFBUSxnQkFBZ0IsRUFBRUYsRUFBRUksTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDQSxTQUFTRSxLQUFLQSxJQUFJO0lBQ2QsSUFBSSxPQUFPQSxTQUFTLGNBQWMsT0FBT0EsS0FBS0MsTUFBTSxLQUFLLFlBQ3JELE1BQU0sSUFBSVQsTUFBTTtJQUNwQkosT0FBT1ksS0FBS0UsU0FBUztJQUNyQmQsT0FBT1ksS0FBS0csUUFBUTtBQUN4QjtBQUNBLFNBQVNDLE9BQU9DLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDMUMsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUlmLE1BQU07SUFDcEIsSUFBSWMsaUJBQWlCRCxTQUFTRyxRQUFRLEVBQ2xDLE1BQU0sSUFBSWhCLE1BQU07QUFDeEI7QUFDQSxTQUFTaUIsT0FBT0MsR0FBRyxFQUFFTCxRQUFRO0lBQ3pCVixNQUFNZTtJQUNOLE1BQU1DLE1BQU1OLFNBQVNILFNBQVM7SUFDOUIsSUFBSVEsSUFBSVosTUFBTSxHQUFHYSxLQUFLO1FBQ2xCLE1BQU0sSUFBSW5CLE1BQU0sQ0FBQyxzREFBc0QsRUFBRW1CLElBQUksQ0FBQztJQUNsRjtBQUNKO0FBQ3FEO0FBQ3JELE1BQU1DLFNBQVM7SUFBRXhCO0lBQVFLO0lBQU1FO0lBQU9LO0lBQU1JO0lBQVFLO0FBQU87QUFDM0QsaUVBQWVHLE1BQU1BLEVBQUMsQ0FDdEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/NzE0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJieXRlcyIsImxlbmd0aHMiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJoYXNoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dHB1dCIsIm91dCIsIm1pbiIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/esm/_u64.js":
/*!****************************************************!*\
  !*** ./app/node_modules/@noble/hashes/esm/_u64.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsK0VBQStFO0FBQy9FLFNBQVNFLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxLQUFLO0lBQzFCLElBQUlBLElBQ0EsT0FBTztRQUFFQyxHQUFHQyxPQUFPSCxJQUFJSjtRQUFhUSxHQUFHRCxPQUFPLEtBQU1MLE9BQVFGO0lBQVk7SUFDNUUsT0FBTztRQUFFTSxHQUFHQyxPQUFPLEtBQU1MLE9BQVFGLGNBQWM7UUFBR1EsR0FBR0QsT0FBT0gsSUFBSUosY0FBYztJQUFFO0FBQ3BGO0FBQ0EsU0FBU1MsTUFBTUMsR0FBRyxFQUFFTCxLQUFLLEtBQUs7SUFDMUIsSUFBSU0sS0FBSyxJQUFJQyxZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUlDLEtBQUssSUFBSUYsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUFLO1FBQ2pDLE1BQU0sRUFBRVQsQ0FBQyxFQUFFRSxDQUFDLEVBQUUsR0FBR0wsUUFBUU8sR0FBRyxDQUFDSyxFQUFFLEVBQUVWO1FBQ2pDLENBQUNNLEVBQUUsQ0FBQ0ksRUFBRSxFQUFFRCxFQUFFLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQUNUO1lBQUdFO1NBQUU7SUFDM0I7SUFDQSxPQUFPO1FBQUNHO1FBQUlHO0tBQUc7QUFDbkI7QUFDQSxNQUFNRSxRQUFRLENBQUNWLEdBQUdFLElBQU0sT0FBUUYsTUFBTSxNQUFNSixPQUFRRCxPQUFPTyxNQUFNO0FBQ2pFLHVCQUF1QjtBQUN2QixNQUFNUyxRQUFRLENBQUNYLEdBQUdZLElBQUlDLElBQU1iLE1BQU1hO0FBQ2xDLE1B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Z0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/ZGQ3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwiZnJvbUJpZyIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwic3BsaXQiLCJsc3QiLCJBaCIsIlVpbnQzMkFycmF5IiwibGVuZ3RoIiwiQWwiLCJpIiwidG9CaWciLCJzaHJTSCIsIl9sIiwicyIsInNoclNMIiwicm90clNIIiwicm90clNMIiwicm90ckJIIiwicm90ckJMIiwicm90cjMySCIsIl9oIiwicm90cjMyTCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsImFkZCIsIkJoIiwiQmwiLCJhZGQzTCIsIkNsIiwiYWRkM0giLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJhZGQ0SCIsIkRoIiwiYWRkNUwiLCJFbCIsImFkZDVIIiwiRWgiLCJ1NjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!**********************************************************!*\
  !*** ./app/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0ZBQW9GO0FBQ3BGLDRCQUE0QjtBQUM1QixpREFBaUQ7QUFDakQsYUFBYTtBQUNxQjtBQUMzQixNQUFNQyxTQUFTRCwyTUFBRUEsSUFBSSxPQUFPQSwyTUFBRUEsS0FBSyxZQUFZLDBOQUFpQkEsR0FBR0Esa0RBQVksR0FBR0csVUFBVSxDQUNuRyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz8zY2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJuYyIsImNyeXB0byIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/esm/sha3.js":
/*!****************************************************!*\
  !*** ./app/node_modules/@noble/hashes/esm/sha3.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./app/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./app/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./app/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDNEI7QUFDOUYsb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDYyxTQUFTQyxXQUFXQyxXQUFXLEdBQUc7SUFBQyxFQUFFO0lBQUUsRUFBRTtJQUFFLEVBQUU7Q0FBQztBQUNyRCxNQUFNQyxNQUFNLGFBQWEsR0FBR0MsT0FBTztBQUNuQyxNQUFNQyxNQUFNLGFBQWEsR0FBR0QsT0FBTztBQUNuQyxNQUFNRSxNQUFNLGFBQWEsR0FBR0YsT0FBTztBQUNuQyxNQUFNRyxNQUFNLGFBQWEsR0FBR0gsT0FBTztBQUNuQyxNQUFNSSxRQUFRLGFBQWEsR0FBR0osT0FBTztBQUNyQyxNQUFNSyxTQUFTLGFBQWEsR0FBR0wsT0FBTztBQUN0QyxJQUFLLElBQUlNLFFBQVEsR0FBR0MsSUFBSU4sS0FBS08sSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNiLFFBQVFjLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYlgsVUFBVWEsSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FBQUEsUUFBUSxLQUFNLElBQUs7SUFDbkQsT0FBTztJQUNQLElBQUlLLElBQUlaO0lBQ1IsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN4QkwsSUFBSSxDQUFDLEtBQU1OLE1BQVEsQ0FBQ00sS0FBS0osR0FBRSxJQUFLRSxNQUFNLElBQUtEO1FBQzNDLElBQUlHLElBQUlMLEtBQ0pTLEtBQUtWLE9BQVEsQ0FBQ0EsT0FBTyxhQUFhLEdBQUdELE9B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TSxNQUFNTSxhQUFhLGFBQWEsR0FBR04sSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1PLGFBQWEsYUFBYSxHQUFHUCxJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDM0QsTUFBTVEsYUFBYSxhQUFhLEdBQUdSLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztBQUNqRSxNQUFNUyxXQUFXLENBQUMxQyxRQUFRRCxVQUFVRSxZQUFjNUMscUVBQTBCQSxDQUFDLENBQUNzRixPQUFPLENBQUMsQ0FBQyxHQUFLLElBQUk5QyxPQUFPRSxVQUFVQyxRQUFRMkMsS0FBS0MsS0FBSyxLQUFLQyxZQUFZNUMsWUFBWTBDLEtBQUtDLEtBQUssRUFBRTtBQUNySyxNQUFNRSxXQUFXLGFBQWEsR0FBR0osU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzlELE1BQU1LLFdBQVcsYUFBYSxHQUFHTCxTQUFTLE1BQU0sS0FBSyxNQUFNLEdBQUcsQ0FDckUsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/ZmNiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBieXRlcywgZXhpc3RzLCBudW1iZXIsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IEhhc2gsIHUzMiwgdG9CeXRlcywgd3JhcENvbnN0cnVjdG9yLCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cywgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCSChoLCBsLCBzKSA6IHJvdGxTSChoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIG51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cygob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMjU2ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJieXRlcyIsImV4aXN0cyIsIm51bWJlciIsIm91dHB1dCIsInJvdGxCSCIsInJvdGxCTCIsInJvdGxTSCIsInJvdGxTTCIsInNwbGl0IiwiSGFzaCIsInUzMiIsInRvQnl0ZXMiLCJ3cmFwQ29uc3RydWN0b3IiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJyb3RsSCIsImgiLCJsIiwicyIsInJvdGxMIiwia2VjY2FrUCIsInJvdW5kcyIsIkIiLCJVaW50MzJBcnJheSIsImlkeDEiLCJpZHgwIiwiQjAiLCJCMSIsIlRoIiwiVGwiLCJjdXJIIiwiY3VyTCIsInNoaWZ0IiwiUEkiLCJmaWxsIiwiS2VjY2FrIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsInN1ZmZpeCIsIm91dHB1dExlbiIsImVuYWJsZVhPRiIsInBvcyIsInBvc091dCIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwiRXJyb3IiLCJzdGF0ZSIsIlVpbnQ4QXJyYXkiLCJzdGF0ZTMyIiwia2VjY2FrIiwidXBkYXRlIiwiZGF0YSIsImxlbiIsImxlbmd0aCIsInRha2UiLCJNYXRoIiwibWluIiwiaSIsImZpbmlzaCIsIndyaXRlSW50byIsIm91dCIsImJ1ZmZlck91dCIsInNldCIsInN1YmFycmF5IiwieG9mSW50byIsInhvZiIsImRpZ2VzdEludG8iLCJkZXN0cm95IiwiZGlnZXN0IiwiX2Nsb25lSW50byIsInRvIiwiZ2VuIiwic2hhM18yMjQiLCJzaGEzXzI1NiIsInNoYTNfMzg0Iiwic2hhM181MTIiLCJrZWNjYWtfMjI0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18zODQiLCJrZWNjYWtfNTEyIiwiZ2VuU2hha2UiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiLCJzaGFrZTEyOCIsInNoYWtlMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/@noble/hashes/esm/utils.js":
/*!*****************************************************!*\
  !*** ./app/node_modules/@noble/hashes/esm/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./app/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCw4REFBOEQ7QUFDaEI7QUFDOUMsTUFBTUMsTUFBTSxDQUFDQyxJQUFNQSxhQUFhQztBQUNoQywrQkFBK0I7QUFDeEIsTUFBTUMsS0FBSyxDQUFDQyxNQUFRLElBQUlGLFdBQVdFLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVLEVBQUU7QUFDL0UsTUFBTUMsTUFBTSxDQUFDSixNQUFRLElBQUlLLFlBQVlMLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFSSxLQUFLQyxLQUFLLENBQUNQLElBQUlHLFVBQVUsR0FBRyxJQUFJO0FBQ3hHLHFCQUFxQjtBQUNkLE1BQU1LLGFBQWEsQ0FBQ1IsTUFBUSxJQUFJUyxTQUFTVCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQzVGLCtEQUErRDtBQUN4RCxNQUFNTyxPQUFPLENBQUNDLE1BQU1DLFFBQVUsUUFBVSxLQUFLQSxRQUFXRCxTQUFTQyxNQUFPO0FBQy9FLGlGQUFpRjtBQUNqRix3REFBd0Q7QUFDakQsTUFBTUMsT0FBTyxJQUFJZixXQUFXLElBQUlPLFlBQVk7SUFBQztDQUFXLEVBQUVKLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLO0FBQ3JGLElBQUksQ0FBQ1ksTUFDRCxNQUFNLElBQUlDLE1BQU07QUFDcEIsTUFBTUMsUUFBUSxhQUFhLEdBQUdDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7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QUFTUDtJQUNsQyxPQUFPUTtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTVSxZQUFZQyxjQUFjLEVBQUU7SUFDeEMsSUFBSXpGLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDMEYsZUFBZSxLQUFLLFlBQVk7UUFDeEQsT0FBTzFGLHdEQUFNQSxDQUFDMEYsZUFBZSxDQUFDLElBQUl2RixXQUFXc0Y7SUFDakQ7SUFDQSxNQUFNLElBQUl0RSxNQUFNO0FBQ3BCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzP2I1ODIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsInU4YSIsImEiLCJVaW50OEFycmF5IiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY3JlYXRlVmlldyIsIkRhdGFWaWV3Iiwicm90ciIsIndvcmQiLCJzaGlmdCIsImlzTEUiLCJFcnJvciIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiaGV4IiwiaGV4VG9CeXRlcyIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwidG9CeXRlcyIsImRhdGEiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiSGFzaCIsImNsb25lIiwiX2Nsb25lSW50byIsInRvU3RyIiwiY2hlY2tPcHRzIiwiZGVmYXVsdHMiLCJvcHRzIiwidW5kZWZpbmVkIiwiY2FsbCIsIm1lcmdlZCIsIk9iamVjdCIsImFzc2lnbiIsIndyYXBDb25zdHJ1Y3RvciIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImNyZWF0ZSIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;