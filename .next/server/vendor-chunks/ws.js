"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(ssr)/./app/node_modules/ws/index.js":
/*!**************************************!*\
  !*** ./app/node_modules/ws/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./app/node_modules/ws/lib/websocket.js\");\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(ssr)/./app/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(ssr)/./app/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(ssr)/./app/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(ssr)/./app/node_modules/ws/lib/sender.js\");\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFFMUJELFVBQVVFLHFCQUFxQixHQUFHRCxtQkFBT0EsQ0FBQztBQUMxQ0QsVUFBVUcsTUFBTSxHQUFHRixtQkFBT0EsQ0FBQztBQUMzQkQsVUFBVUksUUFBUSxHQUFHSCxtQkFBT0EsQ0FBQztBQUM3QkQsVUFBVUssTUFBTSxHQUFHSixtQkFBT0EsQ0FBQztBQUUzQkssT0FBT0MsT0FBTyxHQUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcz81MTNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcbiJdLCJuYW1lcyI6WyJXZWJTb2NrZXQiLCJyZXF1aXJlIiwiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwiU2VydmVyIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/index.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/buffer-util.js":
/*!************************************************!*\
  !*** ./app/node_modules/ws/lib/buffer-util.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ function concat(list, totalLength) {\n    if (list.length === 0) return EMPTY_BUFFER;\n    if (list.length === 1) return list[0];\n    const target = Buffer.allocUnsafe(totalLength);\n    let offset = 0;\n    for(let i = 0; i < list.length; i++){\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n    }\n    if (offset < totalLength) return target.slice(0, offset);\n    return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */ function _mask(source, mask, output, offset, length) {\n    for(let i = 0; i < length; i++){\n        output[offset + i] = source[i] ^ mask[i & 3];\n    }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */ function _unmask(buffer, mask) {\n    // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n    const length = buffer.length;\n    for(let i = 0; i < length; i++){\n        buffer[i] ^= mask[i & 3];\n    }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */ function toArrayBuffer(buf) {\n    if (buf.byteLength === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */ function toBuffer(data) {\n    toBuffer.readOnly = true;\n    if (Buffer.isBuffer(data)) return data;\n    let buf;\n    if (data instanceof ArrayBuffer) {\n        buf = Buffer.from(data);\n    } else if (ArrayBuffer.isView(data)) {\n        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n    } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n    }\n    return buf;\n}\ntry {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"(ssr)/./app/node_modules/bufferutil/index.js\");\n    const bu = bufferUtil.BufferUtil || bufferUtil;\n    module.exports = {\n        concat,\n        mask (source, mask, output, offset, length) {\n            if (length < 48) _mask(source, mask, output, offset, length);\n            else bu.mask(source, mask, output, offset, length);\n        },\n        toArrayBuffer,\n        toBuffer,\n        unmask (buffer, mask) {\n            if (buffer.length < 32) _unmask(buffer, mask);\n            else bu.unmask(buffer, mask);\n        }\n    };\n} catch (e) /* istanbul ignore next */ {\n    module.exports = {\n        concat,\n        mask: _mask,\n        toArrayBuffer,\n        toBuffer,\n        unmask: _unmask\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWpDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxPQUFPQyxJQUFJLEVBQUVDLFdBQVc7SUFDL0IsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT0w7SUFDOUIsSUFBSUcsS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT0YsSUFBSSxDQUFDLEVBQUU7SUFFckMsTUFBTUcsU0FBU0MsT0FBT0MsV0FBVyxDQUFDSjtJQUNsQyxJQUFJSyxTQUFTO0lBRWIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLEtBQUtFLE1BQU0sRUFBRUssSUFBSztRQUNwQyxNQUFNQyxNQUFNUixJQUFJLENBQUNPLEVBQUU7UUFDbkJKLE9BQU9NLEdBQUcsQ0FBQ0QsS0FBS0Y7UUFDaEJBLFVBQVVFLElBQUlOLE1BQU07SUFDdEI7SUFFQSxJQUFJSSxTQUFTTCxhQUFhLE9BQU9FLE9BQU9PLEtBQUssQ0FBQyxHQUFHSjtJQUVqRCxPQUFPSDtBQUNUO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU1EsTUFBTUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRVIsTUFBTSxFQUFFSixNQUFNO0lBQ2pELElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTCxRQUFRSyxJQUFLO1FBQy9CTyxNQUFNLENBQUNSLFNBQVNDLEVBQUUsR0FBR0ssTUFBTSxDQUFDTCxFQUFFLEdBQUdNLElBQUksQ0FBQ04sSUFBSSxFQUFFO0lBQzlDO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTUSxRQUFRQyxNQUFNLEVBQUVILElBQUk7SUFDM0IseUVBQXlFO0lBQ3pFLE1BQU1YLFNBQVNjLE9BQU9kLE1BQU07SUFDNUIsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlMLFFBQVFLLElBQUs7UUFDL0JTLE1BQU0sQ0FBQ1QsRUFBRSxJQUFJTSxJQUFJLENBQUNOLElBQUksRUFBRTtJQUMxQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1UsY0FBY1QsR0FBRztJQUN4QixJQUFJQSxJQUFJVSxVQUFVLEtBQUtWLElBQUlRLE1BQU0sQ0FBQ0UsVUFBVSxFQUFFO1FBQzVDLE9BQU9WLElBQUlRLE1BQU07SUFDbkI7SUFFQSxPQUFPUixJQUFJUSxNQUFNLENBQUNOLEtBQUssQ0FBQ0YsSUFBSVcsVUFBVSxFQUFFWCxJQUFJVyxVQUFVLEdBQUdYLElBQUlVLFVBQVU7QUFDekU7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0UsU0FBU0MsSUFBSTtJQUNwQkQsU0FBU0UsUUFBUSxHQUFHO0lBRXBCLElBQUlsQixPQUFPbUIsUUFBUSxDQUFDRixPQUFPLE9BQU9BO0lBRWxDLElBQUliO0lBRUosSUFBSWEsZ0JBQWdCRyxhQUFhO1FBQy9CaEIsTUFBTUosT0FBT3FCLElBQUksQ0FBQ0o7SUFDcEIsT0FBTyxJQUFJRyxZQUFZRSxNQUFNLENBQUNMLE9BQU87UUFDbkNiLE1BQU1KLE9BQU9xQixJQUFJLENBQUNKLEtBQUtMLE1BQU0sRUFBRUssS0FBS0YsVUFBVSxFQUFFRSxLQUFLSCxVQUFVO0lBQ2pFLE9BQU87UUFDTFYsTUFBTUosT0FBT3FCLElBQUksQ0FBQ0o7UUFDbEJELFNBQVNFLFFBQVEsR0FBRztJQUN0QjtJQUVBLE9BQU9kO0FBQ1Q7QUFFQSxJQUFJO0lBQ0YsTUFBTW1CLGFBQWE3QixtQkFBT0EsQ0FBQztJQUMzQixNQUFNOEIsS0FBS0QsV0FBV0UsVUFBVSxJQUFJRjtJQUVwQ0csT0FBT0MsT0FBTyxHQUFHO1FBQ2ZoQztRQUNBYyxNQUFLRCxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFUixNQUFNLEVBQUVKLE1BQU07WUFDdkMsSUFBSUEsU0FBUyxJQUFJUyxNQUFNQyxRQUFRQyxNQUFNQyxRQUFRUixRQUFRSjtpQkFDaEQwQixHQUFHZixJQUFJLENBQUNELFFBQVFDLE1BQU1DLFFBQVFSLFFBQVFKO1FBQzdDO1FBQ0FlO1FBQ0FHO1FBQ0FZLFFBQU9oQixNQUFNLEVBQUVILElBQUk7WUFDakIsSUFBSUcsT0FBT2QsTUFBTSxHQUFHLElBQUlhLFFBQVFDLFFBQVFIO2lCQUNuQ2UsR0FBR0ksTUFBTSxDQUFDaEIsUUFBUUg7UUFDekI7SUFDRjtBQUNGLEVBQUUsT0FBT29CLEdBQUcsd0JBQXdCLEdBQUc7SUFDckNILE9BQU9DLE9BQU8sR0FBRztRQUNmaEM7UUFDQWMsTUFBTUY7UUFDTk07UUFDQUc7UUFDQVksUUFBUWpCO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanM/NDhlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIC8vIFJlcXVpcmVkIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvOTAwNiBpcyByZXNvbHZlZC5cbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG50cnkge1xuICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuICBjb25zdCBidSA9IGJ1ZmZlclV0aWwuQnVmZmVyVXRpbCB8fCBidWZmZXJVdGlsO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidS5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfSxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzayhidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnUudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJFTVBUWV9CVUZGRVIiLCJyZXF1aXJlIiwiY29uY2F0IiwibGlzdCIsInRvdGFsTGVuZ3RoIiwibGVuZ3RoIiwidGFyZ2V0IiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJpIiwiYnVmIiwic2V0Iiwic2xpY2UiLCJfbWFzayIsInNvdXJjZSIsIm1hc2siLCJvdXRwdXQiLCJfdW5tYXNrIiwiYnVmZmVyIiwidG9BcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwidG9CdWZmZXIiLCJkYXRhIiwicmVhZE9ubHkiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiZnJvbSIsImlzVmlldyIsImJ1ZmZlclV0aWwiLCJidSIsIkJ1ZmZlclV0aWwiLCJtb2R1bGUiLCJleHBvcnRzIiwidW5tYXNrIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/constants.js":
/*!**********************************************!*\
  !*** ./app/node_modules/ws/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    BINARY_TYPES: [\n        \"nodebuffer\",\n        \"arraybuffer\",\n        \"fragments\"\n    ],\n    GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n    kStatusCode: Symbol(\"status-code\"),\n    kWebSocket: Symbol(\"websocket\"),\n    EMPTY_BUFFER: Buffer.alloc(0),\n    NOOP: ()=>{}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGNBQWM7UUFBQztRQUFjO1FBQWU7S0FBWTtJQUN4REMsTUFBTTtJQUNOQyxhQUFhQyxPQUFPO0lBQ3BCQyxZQUFZRCxPQUFPO0lBQ25CRSxjQUFjQyxPQUFPQyxLQUFLLENBQUM7SUFDM0JDLE1BQU0sS0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/NmQzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQklOQVJZX1RZUEVTIiwiR1VJRCIsImtTdGF0dXNDb2RlIiwiU3ltYm9sIiwia1dlYlNvY2tldCIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiTk9PUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/event-target.js":
/*!*************************************************!*\
  !*** ./app/node_modules/ws/lib/event-target.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n/**\n * Class representing an event.\n *\n * @private\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was\n   *     dispatched\n   */ constructor(type, target){\n        this.target = target;\n        this.type = type;\n    }\n}\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */ constructor(data, target){\n        super(\"message\", target);\n        this.data = data;\n    }\n}\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being\n   *     closed\n   * @param {String} reason A human-readable string explaining why the\n   *     connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */ constructor(code, reason, target){\n        super(\"close\", target);\n        this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n        this.reason = reason;\n        this.code = code;\n    }\n}\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */ class OpenEvent extends Event {\n    /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */ constructor(target){\n        super(\"open\", target);\n    }\n}\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */ class ErrorEvent extends Event {\n    /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */ constructor(error, target){\n        super(\"error\", target);\n        this.message = error.message;\n        this.error = error;\n    }\n}\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */ addEventListener (type, listener, options) {\n        if (typeof listener !== \"function\") return;\n        function onMessage(data) {\n            listener.call(this, new MessageEvent(data, this));\n        }\n        function onClose(code, message) {\n            listener.call(this, new CloseEvent(code, message, this));\n        }\n        function onError(error) {\n            listener.call(this, new ErrorEvent(error, this));\n        }\n        function onOpen() {\n            listener.call(this, new OpenEvent(this));\n        }\n        const method = options && options.once ? \"once\" : \"on\";\n        if (type === \"message\") {\n            onMessage._listener = listener;\n            this[method](type, onMessage);\n        } else if (type === \"close\") {\n            onClose._listener = listener;\n            this[method](type, onClose);\n        } else if (type === \"error\") {\n            onError._listener = listener;\n            this[method](type, onError);\n        } else if (type === \"open\") {\n            onOpen._listener = listener;\n            this[method](type, onOpen);\n        } else {\n            this[method](type, listener);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */ removeEventListener (type, listener) {\n        const listeners = this.listeners(type);\n        for(let i = 0; i < listeners.length; i++){\n            if (listeners[i] === listener || listeners[i]._listener === listener) {\n                this.removeListener(type, listeners[i]);\n            }\n        }\n    }\n};\nmodule.exports = EventTarget;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUE7SUFDSjs7Ozs7O0dBTUMsR0FDREMsWUFBWUMsSUFBSSxFQUFFQyxNQUFNLENBQUU7UUFDeEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxJQUFJLEdBQUdBO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUUscUJBQXFCSjtJQUN6Qjs7Ozs7O0dBTUMsR0FDREMsWUFBWUksSUFBSSxFQUFFRixNQUFNLENBQUU7UUFDeEIsS0FBSyxDQUFDLFdBQVdBO1FBRWpCLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtJQUNkO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLG1CQUFtQk47SUFDdkI7Ozs7Ozs7OztHQVNDLEdBQ0RDLFlBQVlNLElBQUksRUFBRUMsTUFBTSxFQUFFTCxNQUFNLENBQUU7UUFDaEMsS0FBSyxDQUFDLFNBQVNBO1FBRWYsSUFBSSxDQUFDTSxRQUFRLEdBQUdOLE9BQU9PLG1CQUFtQixJQUFJUCxPQUFPUSxlQUFlO1FBQ3BFLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtJQUNkO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1LLGtCQUFrQlo7SUFDdEI7Ozs7O0dBS0MsR0FDREMsWUFBWUUsTUFBTSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyxRQUFRQTtJQUNoQjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNVSxtQkFBbUJiO0lBQ3ZCOzs7Ozs7R0FNQyxHQUNEQyxZQUFZYSxLQUFLLEVBQUVYLE1BQU0sQ0FBRTtRQUN6QixLQUFLLENBQUMsU0FBU0E7UUFFZixJQUFJLENBQUNZLE9BQU8sR0FBR0QsTUFBTUMsT0FBTztRQUM1QixJQUFJLENBQUNELEtBQUssR0FBR0E7SUFDZjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNRSxjQUFjO0lBQ2xCOzs7Ozs7Ozs7OztHQVdDLEdBQ0RDLGtCQUFpQmYsSUFBSSxFQUFFZ0IsUUFBUSxFQUFFQyxPQUFPO1FBQ3RDLElBQUksT0FBT0QsYUFBYSxZQUFZO1FBRXBDLFNBQVNFLFVBQVVmLElBQUk7WUFDckJhLFNBQVNHLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSWpCLGFBQWFDLE1BQU0sSUFBSTtRQUNqRDtRQUVBLFNBQVNpQixRQUFRZixJQUFJLEVBQUVRLE9BQU87WUFDNUJHLFNBQVNHLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSWYsV0FBV0MsTUFBTVEsU0FBUyxJQUFJO1FBQ3hEO1FBRUEsU0FBU1EsUUFBUVQsS0FBSztZQUNwQkksU0FBU0csSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJUixXQUFXQyxPQUFPLElBQUk7UUFDaEQ7UUFFQSxTQUFTVTtZQUNQTixTQUFTRyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUlULFVBQVUsSUFBSTtRQUN4QztRQUVBLE1BQU1hLFNBQVNOLFdBQVdBLFFBQVFPLElBQUksR0FBRyxTQUFTO1FBRWxELElBQUl4QixTQUFTLFdBQVc7WUFDdEJrQixVQUFVTyxTQUFTLEdBQUdUO1lBQ3RCLElBQUksQ0FBQ08sT0FBTyxDQUFDdkIsTUFBTWtCO1FBQ3JCLE9BQU8sSUFBSWxCLFNBQVMsU0FBUztZQUMzQm9CLFFBQVFLLFNBQVMsR0FBR1Q7WUFDcEIsSUFBSSxDQUFDTyxPQUFPLENBQUN2QixNQUFNb0I7UUFDckIsT0FBTyxJQUFJcEIsU0FBUyxTQUFTO1lBQzNCcUIsUUFBUUksU0FBUyxHQUFHVDtZQUNwQixJQUFJLENBQUNPLE9BQU8sQ0FBQ3ZCLE1BQU1xQjtRQUNyQixPQUFPLElBQUlyQixTQUFTLFFBQVE7WUFDMUJzQixPQUFPRyxTQUFTLEdBQUdUO1lBQ25CLElBQUksQ0FBQ08sT0FBTyxDQUFDdkIsTUFBTXNCO1FBQ3JCLE9BQU87WUFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQ3ZCLE1BQU1nQjtRQUNyQjtJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ0RVLHFCQUFvQjFCLElBQUksRUFBRWdCLFFBQVE7UUFDaEMsTUFBTVcsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQzNCO1FBRWpDLElBQUssSUFBSTRCLElBQUksR0FBR0EsSUFBSUQsVUFBVUUsTUFBTSxFQUFFRCxJQUFLO1lBQ3pDLElBQUlELFNBQVMsQ0FBQ0MsRUFBRSxLQUFLWixZQUFZVyxTQUFTLENBQUNDLEVBQUUsQ0FBQ0gsU0FBUyxLQUFLVCxVQUFVO2dCQUNwRSxJQUFJLENBQUNjLGNBQWMsQ0FBQzlCLE1BQU0yQixTQUFTLENBQUNDLEVBQUU7WUFDeEM7UUFDRjtJQUNGO0FBQ0Y7QUFFQUcsT0FBT0MsT0FBTyxHQUFHbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcz9hZThhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhc1xuICAgKiAgICAgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIHJlY2VpdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXNcbiAgICogICAgIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHRhcmdldCkge1xuICAgIHN1cGVyKCdtZXNzYWdlJywgdGFyZ2V0KTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBiZWluZ1xuICAgKiAgICAgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXNcbiAgICogICAgIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIHJlYXNvbiwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ2Nsb3NlJywgdGFyZ2V0KTtcblxuICAgIHRoaXMud2FzQ2xlYW4gPSB0YXJnZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0YXJnZXQuX2Nsb3NlRnJhbWVTZW50O1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gb3BlbiBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgT3BlbkV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBPcGVuRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhc1xuICAgKiAgICAgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoJ29wZW4nLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzXG4gICAqICAgICBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvciwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ2Vycm9yJywgdGFyZ2V0KTtcblxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE1lc3NhZ2VFdmVudChkYXRhLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBDbG9zZUV2ZW50KGNvZGUsIG1lc3NhZ2UsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBFcnJvckV2ZW50KGVycm9yLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgT3BlbkV2ZW50KHRoaXMpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zICYmIG9wdGlvbnMub25jZSA/ICdvbmNlJyA6ICdvbic7XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICBvbk1lc3NhZ2UuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgb25NZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIG9uQ2xvc2UuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgb25DbG9zZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBvbkVycm9yLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICBvbk9wZW4uX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgb25PcGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyh0eXBlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuIl0sIm5hbWVzIjpbIkV2ZW50IiwiY29uc3RydWN0b3IiLCJ0eXBlIiwidGFyZ2V0IiwiTWVzc2FnZUV2ZW50IiwiZGF0YSIsIkNsb3NlRXZlbnQiLCJjb2RlIiwicmVhc29uIiwid2FzQ2xlYW4iLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50IiwiT3BlbkV2ZW50IiwiRXJyb3JFdmVudCIsImVycm9yIiwibWVzc2FnZSIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwib3B0aW9ucyIsIm9uTWVzc2FnZSIsImNhbGwiLCJvbkNsb3NlIiwib25FcnJvciIsIm9uT3BlbiIsIm1ldGhvZCIsIm9uY2UiLCJfbGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuZXJzIiwiaSIsImxlbmd0aCIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/extension.js":
/*!**********************************************!*\
  !*** ./app/node_modules/ws/lib/extension.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (dest[name] === undefined) dest[name] = [\n        elem\n    ];\n    else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = Object.create(null);\n    if (header === undefined || header === \"\") return offers;\n    let params = Object.create(null);\n    let mustUnescape = false;\n    let isEscaping = false;\n    let inQuotes = false;\n    let extensionName;\n    let paramName;\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 /* ' ' */  || code === 0x09 /* '\\t' */ ) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = Object.create(null);\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                let value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, params);\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */ function format(extensions) {\n    return Object.keys(extensions).map((extension)=>{\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [\n            configurations\n        ];\n        return configurations.map((params)=>{\n            return [\n                extension\n            ].concat(Object.keys(params).map((k)=>{\n                let values = params[k];\n                if (!Array.isArray(values)) values = [\n                    values\n                ];\n                return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRiwrQ0FBK0M7QUFDL0MsOENBQThDO0FBQzlDLEVBQUU7QUFDRiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixNQUFNO0FBQ04sRUFBRTtBQUNGLGtCQUFrQjtBQUNsQixNQUFNQSxhQUFhO0lBQ2pCO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLEVBQUUsWUFBWTtD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QVFLLFdBQVdXO1FBQzFCO1FBQ0ExQixLQUFLTyxRQUFRTyxlQUFlSjtJQUM5QjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTb0IsT0FBT0MsVUFBVTtJQUN4QixPQUFPcEIsT0FBT3FCLElBQUksQ0FBQ0QsWUFDaEJFLEdBQUcsQ0FBQyxDQUFDQztRQUNKLElBQUlDLGlCQUFpQkosVUFBVSxDQUFDRyxVQUFVO1FBQzFDLElBQUksQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDRixpQkFBaUJBLGlCQUFpQjtZQUFDQTtTQUFlO1FBQ3JFLE9BQU9BLGVBQ0pGLEdBQUcsQ0FBQyxDQUFDcEI7WUFDSixPQUFPO2dCQUFDcUI7YUFBVSxDQUNmSSxNQUFNLENBQ0wzQixPQUFPcUIsSUFBSSxDQUFDbkIsUUFBUW9CLEdBQUcsQ0FBQyxDQUFDTTtnQkFDdkIsSUFBSUMsU0FBUzNCLE1BQU0sQ0FBQzBCLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ0gsTUFBTUMsT0FBTyxDQUFDRyxTQUFTQSxTQUFTO29CQUFDQTtpQkFBTztnQkFDN0MsT0FBT0EsT0FDSlAsR0FBRyxDQUFDLENBQUNRLElBQU9BLE1BQU0sT0FBT0YsSUFBSSxDQUFDLEVBQUVBLEVBQUUsQ0FBQyxFQUFFRSxFQUFFLENBQUMsRUFDeENDLElBQUksQ0FBQztZQUNWLElBRURBLElBQUksQ0FBQztRQUNWLEdBQ0NBLElBQUksQ0FBQztJQUNWLEdBQ0NBLElBQUksQ0FBQztBQUNWO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUFFZDtJQUFRdEI7QUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzP2ZlMTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBBZGRzIGFuIG9mZmVyIHRvIHRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBhIHBhcmFtZXRlciB0byB0aGUgbWFwIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXh0ZW5zaW9uIG9yIHBhcmFtZXRlciBuYW1lXG4gKiBAcGFyYW0geyhPYmplY3R8Qm9vbGVhbnxTdHJpbmcpfSBlbGVtIFRoZSBleHRlbnNpb24gcGFyYW1ldGVycyBvciB0aGVcbiAqICAgICBwYXJhbWV0ZXIgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xuICBpZiAoZGVzdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSBkZXN0W25hbWVdID0gW2VsZW1dO1xuICBlbHNlIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCB8fCBoZWFkZXIgPT09ICcnKSByZXR1cm4gb2ZmZXJzO1xuXG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkgLyogJ1xcdCcgKi8pIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3Rlcykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHB1c2gocGFyYW1zLCB0b2tlbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuLnJlcGxhY2UoL1xcXFwvZywgJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4pO1xuICAgIH1cbiAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBvZmZlcnM7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgZmllbGQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIG1hcCBvZiBleHRlbnNpb25zIGFuZCBwYXJhbWV0ZXJzIHRvIGZvcm1hdFxuICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtYXQoZXh0ZW5zaW9ucykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucylcbiAgICAubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9ucyA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uc1xuICAgICAgICAubWFwKChwYXJhbXMpID0+IHtcbiAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl1cbiAgICAgICAgICAgIC5jb25jYXQoXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykubWFwKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHBhcmFtc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfSlcbiAgICAuam9pbignLCAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGZvcm1hdCwgcGFyc2UgfTtcbiJdLCJuYW1lcyI6WyJ0b2tlbkNoYXJzIiwicHVzaCIsImRlc3QiLCJuYW1lIiwiZWxlbSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaGVhZGVyIiwib2ZmZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwicGFyYW1zIiwibXVzdFVuZXNjYXBlIiwiaXNFc2NhcGluZyIsImluUXVvdGVzIiwiZXh0ZW5zaW9uTmFtZSIsInBhcmFtTmFtZSIsInN0YXJ0IiwiZW5kIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJzbGljZSIsInZhbHVlIiwicmVwbGFjZSIsInRva2VuIiwiZm9ybWF0IiwiZXh0ZW5zaW9ucyIsImtleXMiLCJtYXAiLCJleHRlbnNpb24iLCJjb25maWd1cmF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImsiLCJ2YWx1ZXMiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/limiter.js":
/*!********************************************!*\
  !*** ./app/node_modules/ws/lib/limiter.js ***!
  \********************************************/
/***/ ((module) => {

eval("\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */ class Limiter {\n    /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */ constructor(concurrency){\n        this[kDone] = ()=>{\n            this.pending--;\n            this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n    }\n    /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */ add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n    }\n    /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */ [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n            const job = this.jobs.shift();\n            this.pending++;\n            job(this[kDone]);\n        }\n    }\n}\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsUUFBUUMsT0FBTztBQUNyQixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCOzs7Q0FHQyxHQUNELE1BQU1FO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0wsTUFBTSxHQUFHO1lBQ1osSUFBSSxDQUFDTSxPQUFPO1lBQ1osSUFBSSxDQUFDSixLQUFLO1FBQ1o7UUFDQSxJQUFJLENBQUNHLFdBQVcsR0FBR0EsZUFBZUU7UUFDbEMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ0YsT0FBTyxHQUFHO0lBQ2pCO0lBRUE7Ozs7O0dBS0MsR0FDREcsSUFBSUMsR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDRixJQUFJLENBQUNHLElBQUksQ0FBQ0Q7UUFDZixJQUFJLENBQUNSLEtBQUs7SUFDWjtJQUVBOzs7O0dBSUMsR0FDRCxDQUFDQSxLQUFLLEdBQUc7UUFDUCxJQUFJLElBQUksQ0FBQ0ksT0FBTyxLQUFLLElBQUksQ0FBQ0QsV0FBVyxFQUFFO1FBRXZDLElBQUksSUFBSSxDQUFDRyxJQUFJLENBQUNJLE1BQU0sRUFBRTtZQUNwQixNQUFNRixNQUFNLElBQUksQ0FBQ0YsSUFBSSxDQUFDSyxLQUFLO1lBRTNCLElBQUksQ0FBQ1AsT0FBTztZQUNaSSxJQUFJLElBQUksQ0FBQ1YsTUFBTTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcz9lODljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qga0RvbmUgPSBTeW1ib2woJ2tEb25lJyk7XG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXG4gKi9cbmNsYXNzIExpbWl0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgTGltaXRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcbiAgICogICAgIHRvIHJ1biBjb25jdXJyZW50bHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG4gICAgdGhpc1trRG9uZV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgIHRoaXNba1J1bl0oKTtcbiAgICB9O1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmpvYnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKGpvYikge1xuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XG4gICAgdGhpc1trUnVuXSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUgYW5kIHJ1bnMgaXQgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBba1J1bl0oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuXG4gICAgICB0aGlzLnBlbmRpbmcrKztcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcbiJdLCJuYW1lcyI6WyJrRG9uZSIsIlN5bWJvbCIsImtSdW4iLCJMaW1pdGVyIiwiY29uc3RydWN0b3IiLCJjb25jdXJyZW5jeSIsInBlbmRpbmciLCJJbmZpbml0eSIsImpvYnMiLCJhZGQiLCJqb2IiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/permessage-deflate.js":
/*!*******************************************************!*\
  !*** ./app/node_modules/ws/lib/permessage-deflate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./app/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./app/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter(concurrency);\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            this._inflate.close();\n            this._inflate = null;\n        }\n        if (this._deflate) {\n            const callback = this._deflate[kCallback];\n            this._deflate.close();\n            this._deflate = null;\n            if (callback) {\n                callback(new Error(\"The deflate stream was closed while data was being processed\"));\n            }\n        }\n    }\n    /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params)=>{\n            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return false;\n            }\n            return true;\n        });\n        if (!accepted) {\n            throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n            accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n            accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n            accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n            accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n            delete accepted.client_max_window_bits;\n        }\n        return accepted;\n    }\n    /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n            throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */ normalizeParams(configurations) {\n        configurations.forEach((params)=>{\n            Object.keys(params).forEach((key)=>{\n                let value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Parameter \"${key}\" must have only a single value`);\n                }\n                value = value[0];\n                if (key === \"client_max_window_bits\") {\n                    if (value !== true) {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (!this._isServer) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else if (key === \"server_max_window_bits\") {\n                    const num = +value;\n                    if (!Number.isInteger(num) || num < 8 || num > 15) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                    value = num;\n                } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                    if (value !== true) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else {\n                    throw new Error(`Unknown parameter \"${key}\"`);\n                }\n                params[key] = value;\n            });\n        });\n        return configurations;\n    }\n    /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                ...this._options.zlibInflateOptions,\n                windowBits\n            });\n            this._inflate[kPerMessageDeflate] = this;\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (this._inflate._readableState.endEmitted) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._inflate.reset();\n                }\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                ...this._options.zlibDeflateOptions,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            //\n            // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n            // `zlib.DeflateRaw` instance is closed while data is being processed.\n            // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n            // time due to an abnormal WebSocket closure.\n            //\n            this._deflate.on(\"error\", NOOP);\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            if (!this._deflate) {\n                //\n                // The deflate stream was closed while data was being processed.\n                //\n                return;\n            }\n            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) data = data.slice(0, data.length - 4);\n            //\n            // Ensure that the callback will not be called again in\n            // `PerMessageDeflate#cleanup()`.\n            //\n            this._deflate[kCallback] = null;\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                this._deflate.reset();\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new RangeError(\"Max payload size exceeded\");\n    this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n    this[kError][kStatusCode] = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kPerMessageDeflate]._inflate = null;\n    err[kStatusCode] = 1007;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVHLFdBQVcsRUFBRUMsSUFBSSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBRXRDLE1BQU1LLFVBQVVDLE9BQU9DLElBQUksQ0FBQztJQUFDO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDcEQsTUFBTUMscUJBQXFCQyxPQUFPO0FBQ2xDLE1BQU1DLGVBQWVELE9BQU87QUFDNUIsTUFBTUUsWUFBWUYsT0FBTztBQUN6QixNQUFNRyxXQUFXSCxPQUFPO0FBQ3hCLE1BQU1JLFNBQVNKLE9BQU87QUFFdEIsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSxxRkFBcUY7QUFDckYsbURBQW1EO0FBQ25ELEVBQUU7QUFDRixxRUFBcUU7QUFDckUsRUFBRTtBQUNGLElBQUlLO0FBRUo7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxDQUFFO1FBQ3pDLElBQUksQ0FBQ0MsV0FBVyxHQUFHRCxhQUFhO1FBQ2hDLElBQUksQ0FBQ0UsUUFBUSxHQUFHSixXQUFXLENBQUM7UUFDNUIsSUFBSSxDQUFDSyxVQUFVLEdBQ2IsSUFBSSxDQUFDRCxRQUFRLENBQUNFLFNBQVMsS0FBS0MsWUFBWSxJQUFJLENBQUNILFFBQVEsQ0FBQ0UsU0FBUyxHQUFHO1FBQ3BFLElBQUksQ0FBQ0UsU0FBUyxHQUFHLENBQUMsQ0FBQ1A7UUFDbkIsSUFBSSxDQUFDUSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFFaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFFZCxJ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SSxDQUFDUixTQUFTLENBQUNxRixJQUFJLENBQUNEO1FBQ3BCO0lBQ0Y7SUFFQSxJQUFJLENBQUNuRixPQUFPLEdBQUcsSUFBSXFGLFdBQVc7SUFDOUIsSUFBSSxDQUFDckYsT0FBTyxDQUFDc0YsSUFBSSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQ1YsWUFBWSxHQUFHO0lBQzVCLElBQUksQ0FBQ2lHLGNBQWMsQ0FBQyxRQUFRbEI7SUFDNUIsSUFBSSxDQUFDTSxLQUFLO0FBQ1o7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNQLGVBQWVWLEdBQUc7SUFDekIsRUFBRTtJQUNGLHlFQUF5RTtJQUN6RSxtQ0FBbUM7SUFDbkMsRUFBRTtJQUNGLElBQUksQ0FBQy9ELG1CQUFtQixDQUFDbUIsUUFBUSxHQUFHO0lBQ3BDNEMsR0FBRyxDQUFDcEUsWUFBWSxHQUFHO0lBQ25CLElBQUksQ0FBQ1EsVUFBVSxDQUFDNEQ7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcz9lMzRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAvL1xuICAgICAgLy8gQW4gYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQsIG9ubHkgb24gTm9kZS5qcyA8IDEwLjAuMCwgaWYgdGhlXG4gICAgICAvLyBgemxpYi5EZWZsYXRlUmF3YCBpbnN0YW5jZSBpcyBjbG9zZWQgd2hpbGUgZGF0YSBpcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAgaXMgY2FsbGVkIGF0IHRoZSB3cm9uZ1xuICAgICAgLy8gdGltZSBkdWUgdG8gYW4gYWJub3JtYWwgV2ViU29ja2V0IGNsb3N1cmUuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZXJyb3InLCBOT09QKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSBkYXRhID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIDQpO1xuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOlsiemxpYiIsInJlcXVpcmUiLCJidWZmZXJVdGlsIiwiTGltaXRlciIsImtTdGF0dXNDb2RlIiwiTk9PUCIsIlRSQUlMRVIiLCJCdWZmZXIiLCJmcm9tIiwia1Blck1lc3NhZ2VEZWZsYXRlIiwiU3ltYm9sIiwia1RvdGFsTGVuZ3RoIiwia0NhbGxiYWNrIiwia0J1ZmZlcnMiLCJrRXJyb3IiLCJ6bGliTGltaXRlciIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaXNTZXJ2ZXIiLCJtYXhQYXlsb2FkIiwiX21heFBheWxvYWQiLCJfb3B0aW9ucyIsIl90aHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJ1bmRlZmluZWQiLCJfaXNTZXJ2ZXIiLCJfZGVmbGF0ZSIsIl9pbmZsYXRlIiwicGFyYW1zIiwiY29uY3VycmVuY3kiLCJjb25jdXJyZW5jeUxpbWl0IiwiZXh0ZW5zaW9uTmFtZSIsIm9mZmVyIiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciIsImNsaWVudE5vQ29udGV4dFRha2VvdmVyIiwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwic2VydmVyX21heF93aW5kb3dfYml0cyIsImNsaWVudE1heFdpbmRvd0JpdHMiLCJjbGllbnRfbWF4X3dpbmRvd19iaXRzIiwiYWNjZXB0IiwiY29uZmlndXJhdGlvbnMiLCJub3JtYWxpemVQYXJhbXMiLCJhY2NlcHRBc1NlcnZlciIsImFjY2VwdEFzQ2xpZW50IiwiY2xlYW51cCIsImNsb3NlIiwiY2FsbGJhY2siLCJFcnJvciIsIm9mZmVycyIsIm9wdHMiLCJhY2NlcHRlZCIsImZpbmQiLCJyZXNwb25zZSIsImZvckVhY2giLCJPYmplY3QiLCJrZXlzIiwia2V5IiwidmFsdWUiLCJsZW5ndGgiLCJudW0iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJUeXBlRXJyb3IiLCJkZWNvbXByZXNzIiwiZGF0YSIsImZpbiIsImFkZCIsImRvbmUiLCJfZGVjb21wcmVzcyIsImVyciIsInJlc3VsdCIsImNvbXByZXNzIiwiX2NvbXByZXNzIiwiZW5kcG9pbnQiLCJ3aW5kb3dCaXRzIiwiWl9ERUZBVUxUX1dJTkRPV0JJVFMiLCJjcmVhdGVJbmZsYXRlUmF3IiwiemxpYkluZmxhdGVPcHRpb25zIiwib24iLCJpbmZsYXRlT25FcnJvciIsImluZmxhdGVPbkRhdGEiLCJ3cml0ZSIsImZsdXNoIiwiY29uY2F0IiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwicmVzZXQiLCJjcmVhdGVEZWZsYXRlUmF3IiwiemxpYkRlZmxhdGVPcHRpb25zIiwiZGVmbGF0ZU9uRGF0YSIsIlpfU1lOQ19GTFVTSCIsInNsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNodW5rIiwicHVzaCIsIlJhbmdlRXJyb3IiLCJjb2RlIiwicmVtb3ZlTGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/receiver.js":
/*!*********************************************!*\
  !*** ./app/node_modules/ws/lib/receiver.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./app/node_modules/ws/lib/permessage-deflate.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./app/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/./app/node_modules/ws/lib/validation.js\");\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */ class Receiver extends Writable {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} [binaryType=nodebuffer] The type for binary data\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Boolean} [isServer=false] Specifies whether to operate in client or\n   *     server mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(binaryType, extensions, isServer, maxPayload){\n        super();\n        this._binaryType = binaryType || BINARY_TYPES[0];\n        this[kWebSocket] = undefined;\n        this._extensions = extensions || {};\n        this._isServer = !!isServer;\n        this._maxPayload = maxPayload | 0;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = undefined;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._state = GET_INFO;\n        this._loop = false;\n    }\n    /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */ _write(chunk, encoding, cb) {\n        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n    }\n    /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */ consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n            const buf = this._buffers[0];\n            this._buffers[0] = buf.slice(n);\n            return buf.slice(0, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n            const buf = this._buffers[0];\n            const offset = dst.length - n;\n            if (n >= buf.length) {\n                dst.set(this._buffers.shift(), offset);\n            } else {\n                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                this._buffers[0] = buf.slice(n);\n            }\n            n -= buf.length;\n        }while (n > 0);\n        return dst;\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ startLoop(cb) {\n        let err;\n        this._loop = true;\n        do {\n            switch(this._state){\n                case GET_INFO:\n                    err = this.getInfo();\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    err = this.getPayloadLength16();\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    err = this.getPayloadLength64();\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    err = this.getData(cb);\n                    break;\n                default:\n                    // `INFLATING`\n                    this._loop = false;\n                    return;\n            }\n        }while (this._loop);\n        cb(err);\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getInfo() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            this._loop = false;\n            return error(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            this._loop = false;\n            return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (!this._fragmented) {\n                this._loop = false;\n                return error(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._opcode = this._fragmented;\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                this._loop = false;\n                return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                this._loop = false;\n                return error(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n            }\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (this._payloadLength > 0x7d) {\n                this._loop = false;\n                return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n            }\n        } else {\n            this._loop = false;\n            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._isServer) {\n            if (!this._masked) {\n                this._loop = false;\n                return error(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n            }\n        } else if (this._masked) {\n            this._loop = false;\n            return error(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength16() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength64() {\n        if (this._bufferedBytes < 8) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            this._loop = false;\n            return error(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        return this.haveLength();\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ haveLength() {\n        if (this._payloadLength && this._opcode < 0x08) {\n            this._totalPayloadLength += this._payloadLength;\n            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                this._loop = false;\n                return error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n            }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (this._bufferedBytes < 4) {\n            this._loop = false;\n            return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (this._bufferedBytes < this._payloadLength) {\n                this._loop = false;\n                return;\n            }\n            data = this.consume(this._payloadLength);\n            if (this._masked) unmask(data, this._mask);\n        }\n        if (this._opcode > 0x07) return this.controlMessage(data);\n        if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data, cb);\n            return;\n        }\n        if (data.length) {\n            //\n            // This message is not compressed so its lenght is the sum of the payload\n            // length of all fragments.\n            //\n            this._messageLength = this._totalPayloadLength;\n            this._fragments.push(data);\n        }\n        return this.dataMessage();\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */ decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) return cb(err);\n            if (buf.length) {\n                this._messageLength += buf.length;\n                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                    return cb(error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"));\n                }\n                this._fragments.push(buf);\n            }\n            const er = this.dataMessage();\n            if (er) return cb(er);\n            this.startLoop(cb);\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */ dataMessage() {\n        if (this._fin) {\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                let data;\n                if (this._binaryType === \"nodebuffer\") {\n                    data = concat(fragments, messageLength);\n                } else if (this._binaryType === \"arraybuffer\") {\n                    data = toArrayBuffer(concat(fragments, messageLength));\n                } else {\n                    data = fragments;\n                }\n                this.emit(\"message\", data);\n            } else {\n                const buf = concat(fragments, messageLength);\n                if (!isValidUTF8(buf)) {\n                    this._loop = false;\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"message\", buf.toString());\n            }\n        }\n        this._state = GET_INFO;\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ controlMessage(data) {\n        if (this._opcode === 0x08) {\n            this._loop = false;\n            if (data.length === 0) {\n                this.emit(\"conclude\", 1005, \"\");\n                this.end();\n            } else if (data.length === 1) {\n                return error(RangeError, \"invalid payload length 1\", true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n            } else {\n                const code = data.readUInt16BE(0);\n                if (!isValidStatusCode(code)) {\n                    return error(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                }\n                const buf = data.slice(2);\n                if (!isValidUTF8(buf)) {\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"conclude\", code, buf.toString());\n                this.end();\n            }\n        } else if (this._opcode === 0x09) {\n            this.emit(\"ping\", data);\n        } else {\n            this.emit(\"pong\", data);\n        }\n        this._state = GET_INFO;\n    }\n}\nmodule.exports = Receiver;\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */ function error(ErrorCtor, message, prefix, statusCode, errorCode) {\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, error);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsUUFBUSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUNKRSxZQUFZLEVBQ1pDLFlBQVksRUFDWkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1gsR0FBR0wsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVNLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxNQUFNLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDbEQsTUFBTSxFQUFFUyxpQkFBaUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRW5ELE1BQU1XLFdBQVc7QUFDakIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsWUFBWTtBQUVsQjs7OztDQUlDLEdBQ0QsTUFBTUMsaUJBQWlCbEI7SUFDckI7Ozs7Ozs7O0dBUUMsR0FDRG1CLFlBQVlDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUN4RCxLQUFLO1FBRUwsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLGNBQWNqQixZQUFZLENBQUMsRUFBRTtRQUNoRCxJQUFJLENBQUNHLFdBQVcsR0FBR21CO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHTCxjQUFjLENBQUM7UUFDbEMsSUFBSSxDQUFDTSxTQUFTLEdBQUcsQ0FBQyxDQUFDTDtRQUNuQixJQUFJLENBQUNNLFdBQVcsR0FBR0wsYUFBYTtRQUVoQyxJQUFJLENBQUNNLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBRWxCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FB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RUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFNBQVM7SUFDOUQsTUFBTW5DLE1BQU0sSUFBSStCLFVBQ2RFLFNBQVMsQ0FBQyx5QkFBeUIsRUFBRUQsUUFBUSxDQUFDLEdBQUdBO0lBR25EUCxNQUFNVyxpQkFBaUIsQ0FBQ3BDLEtBQUtNO0lBQzdCTixJQUFJNEIsSUFBSSxHQUFHTztJQUNYbkMsR0FBRyxDQUFDMUQsWUFBWSxHQUFHNEY7SUFDbkIsT0FBT2xDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzPzg2ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtiaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW4gY2xpZW50IG9yXG4gICAqICAgICBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IoYmluYXJ5VHlwZSwgZXh0ZW5zaW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGNiKGVycik7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmdodCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsICcnKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgcGF5bG9hZCBsZW5ndGggMScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwMixcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DTE9TRV9DT0RFJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBkYXRhLnNsaWNlKDIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOSkge1xuICAgICAgdGhpcy5lbWl0KCdwaW5nJywgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgncG9uZycsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcblxuLyoqXG4gKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gKiAgICAgYG1lc3NhZ2VgXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxuICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlLCBlcnJvckNvZGUpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICApO1xuXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgZXJyb3IpO1xuICBlcnIuY29kZSA9IGVycm9yQ29kZTtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gIHJldHVybiBlcnI7XG59XG4iXSwibmFtZXMiOlsiV3JpdGFibGUiLCJyZXF1aXJlIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJCSU5BUllfVFlQRVMiLCJFTVBUWV9CVUZGRVIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJjb25jYXQiLCJ0b0FycmF5QnVmZmVyIiwidW5tYXNrIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJpc1ZhbGlkVVRGOCIsIkdFVF9JTkZPIiwiR0VUX1BBWUxPQURfTEVOR1RIXzE2IiwiR0VUX1BBWUxPQURfTEVOR1RIXzY0IiwiR0VUX01BU0siLCJHRVRfREFUQSIsIklORkxBVElORyIsIlJlY2VpdmVyIiwiY29uc3RydWN0b3IiLCJiaW5hcnlUeXBlIiwiZXh0ZW5zaW9ucyIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsIl9iaW5hcnlUeXBlIiwidW5kZWZpbmVkIiwiX2V4dGVuc2lvbnMiLCJfaXNTZXJ2ZXIiLCJfbWF4UGF5bG9hZCIsIl9idWZmZXJlZEJ5dGVzIiwiX2J1ZmZlcnMiLCJfY29tcHJlc3NlZCIsIl9wYXlsb2FkTGVuZ3RoIiwiX21hc2siLCJfZnJhZ21lbnRlZCIsIl9tYXNrZWQiLCJfZmluIiwiX29wY29kZSIsIl90b3RhbFBheWxvYWRMZW5ndGgiLCJfbWVzc2FnZUxlbmd0aCIsIl9mcmFnbWVudHMiLCJfc3RhdGUiLCJfbG9vcCIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImxlbmd0aCIsInB1c2giLCJzdGFydExvb3AiLCJjb25zdW1lIiwibiIsInNoaWZ0IiwiYnVmIiwic2xpY2UiLCJkc3QiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsInNldCIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiZXJyIiwiZ2V0SW5mbyIsImdldFBheWxvYWRMZW5ndGgxNiIsImdldFBheWxvYWRMZW5ndGg2NCIsImdldE1hc2siLCJnZXREYXRhIiwiZXJyb3IiLCJSYW5nZUVycm9yIiwiY29tcHJlc3NlZCIsImV4dGVuc2lvbk5hbWUiLCJoYXZlTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwibnVtIiwicmVhZFVJbnQzMkJFIiwiTWF0aCIsInBvdyIsImRhdGEiLCJjb250cm9sTWVzc2FnZSIsImRlY29tcHJlc3MiLCJkYXRhTWVzc2FnZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXIiLCJtZXNzYWdlTGVuZ3RoIiwiZnJhZ21lbnRzIiwiZW1pdCIsIkVycm9yIiwidG9TdHJpbmciLCJlbmQiLCJjb2RlIiwibW9kdWxlIiwiZXhwb3J0cyIsIkVycm9yQ3RvciIsIm1lc3NhZ2UiLCJwcmVmaXgiLCJzdGF0dXNDb2RlIiwiZXJyb3JDb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/sender.js":
/*!*******************************************!*\
  !*** ./app/node_modules/ws/lib/sender.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */ \nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./app/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./app/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./app/node_modules/ws/lib/buffer-util.js\");\nconst mask = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   */ constructor(socket, extensions){\n        this._extensions = extensions || {};\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._deflating = false;\n        this._queue = [];\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */ static frame(data, options) {\n        const merge = options.mask && options.readOnly;\n        let offset = options.mask ? 6 : 2;\n        let payloadLength = data.length;\n        if (data.length >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (data.length > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(data.length, 2);\n        } else if (payloadLength === 127) {\n            target.writeUInt32BE(0, 2);\n            target.writeUInt32BE(data.length, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        randomFillSync(mask, 0, 4);\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (merge) {\n            applyMask(data, mask, target, offset, data.length);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, data.length);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {String} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || data === \"\") {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            buf.write(data, 2);\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doClose,\n                buf,\n                mask,\n                cb\n            ]);\n        } else {\n            this.doClose(buf, mask, cb);\n        }\n    }\n    /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @private\n   */ doClose(data, mask, cb) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x08,\n            mask,\n            readOnly: false\n        }), cb);\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        const buf = toBuffer(data);\n        if (buf.length > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doPing,\n                buf,\n                mask,\n                toBuffer.readOnly,\n                cb\n            ]);\n        } else {\n            this.doPing(buf, mask, toBuffer.readOnly, cb);\n        }\n    }\n    /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */ doPing(data, mask, readOnly, cb) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x09,\n            mask,\n            readOnly\n        }), cb);\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        const buf = toBuffer(data);\n        if (buf.length > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doPong,\n                buf,\n                mask,\n                toBuffer.readOnly,\n                cb\n            ]);\n        } else {\n            this.doPong(buf, mask, toBuffer.readOnly, cb);\n        }\n    }\n    /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */ doPong(data, mask, readOnly, cb) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x0a,\n            mask,\n            readOnly\n        }), cb);\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const buf = toBuffer(data);\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate) {\n                rsv1 = buf.length >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        if (perMessageDeflate) {\n            const opts = {\n                fin: options.fin,\n                rsv1,\n                opcode,\n                mask: options.mask,\n                readOnly: toBuffer.readOnly\n            };\n            if (this._deflating) {\n                this.enqueue([\n                    this.dispatch,\n                    buf,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(buf, this._compress, opts, cb);\n            }\n        } else {\n            this.sendFrame(Sender.frame(buf, {\n                fin: options.fin,\n                rsv1: false,\n                opcode,\n                mask: options.mask,\n                readOnly: toBuffer.readOnly\n            }), cb);\n        }\n    }\n    /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += data.length;\n        this._deflating = true;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                if (typeof cb === \"function\") cb(err);\n                for(let i = 0; i < this._queue.length; i++){\n                    const callback = this._queue[i][4];\n                    if (typeof callback === \"function\") callback(err);\n                }\n                return;\n            }\n            this._bufferedBytes -= data.length;\n            this._deflating = false;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(!this._deflating && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[1].length;\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[1].length;\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFLEdBRTFFO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFRSxjQUFjLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUcsb0JBQW9CSCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVJLFlBQVksRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVLLGlCQUFpQixFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFBRU0sTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFOUMsTUFBTU0sT0FBT0csT0FBT0MsS0FBSyxDQUFDO0FBRTFCOztDQUVDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7R0FLQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNDLFdBQVcsR0FBR0QsY0FBYyxDQUFDO1FBQ2xDLElBQUksQ0FBQ0UsT0FBTyxHQUFHSDtRQUVmLElBQUksQ0FBQ0ksY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBRWpCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7SUFDbEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7OztHQWdCQyxHQUNELE9BQU9DLE1BQU1DLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQzFCLE1BQU1DLFFBQVFELFFBQVFsQixJQUFJLElBQUlrQixRQUFRRSxRQUFRO1FBQzlDLElBQUlDLFNBQVNILFFBQVFsQixJQUFJLEdBQUcsSUFBSTtRQUNoQyxJQUFJc0IsZ0JBQWdCTCxLQUFLTSxNQUFNO1FBRS9CLElBQUlOLEtBQUtN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QUU7WUFDMUIsSUFBSSxDQUFDMUQsT0FBTyxDQUFDNkIsS0FBSyxDQUFDNkIsSUFBSSxDQUFDLEVBQUUsRUFBRW5DO1lBQzVCLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQzRELE1BQU07UUFDckIsT0FBTztZQUNMLElBQUksQ0FBQzVELE9BQU8sQ0FBQzZCLEtBQUssQ0FBQzZCLElBQUksQ0FBQyxFQUFFLEVBQUVuQztRQUM5QjtJQUNGO0FBQ0Y7QUFFQXNDLE9BQU9DLE9BQU8sR0FBR25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanM/ODhjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IG1hc2sgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfSBUaGUgZnJhbWVkIGRhdGEgYXMgYSBsaXN0IG9mIGBCdWZmZXJgIGluc3RhbmNlc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHk7XG4gICAgbGV0IG9mZnNldCA9IG9wdGlvbnMubWFzayA/IDYgOiAyO1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YS5sZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhLmxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKDAsIDIpO1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoZGF0YS5sZW5ndGgsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICByYW5kb21GaWxsU3luYyhtYXNrLCAwLCA0KTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gJycpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9DbG9zZSwgYnVmLCBtYXNrLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvQ2xvc2UoYnVmLCBtYXNrLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBjbG9zZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb0Nsb3NlKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUGluZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb1BpbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MDksXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9Qb25nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUG9uZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwb25nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUG9uZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJzdjEgJiYgcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgcnN2MSA9IGJ1Zi5sZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICByc3YxLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgcmVhZE9ubHk6IHRvQnVmZmVyLnJlYWRPbmx5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgICAgU2VuZGVyLmZyYW1lKGJ1Ziwge1xuICAgICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgICAgb3Bjb2RlLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX3F1ZXVlW2ldWzRdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG4iXSwibmFtZXMiOlsibmV0IiwicmVxdWlyZSIsInRscyIsInJhbmRvbUZpbGxTeW5jIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFTVBUWV9CVUZGRVIiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsIm1hc2siLCJhcHBseU1hc2siLCJ0b0J1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiX2V4dGVuc2lvbnMiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9kZWZsYXRpbmciLCJfcXVldWUiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJyZWFkT25seSIsIm9mZnNldCIsInBheWxvYWRMZW5ndGgiLCJsZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJCRSIsImNsb3NlIiwiY29kZSIsImNiIiwiYnVmIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiYnl0ZUxlbmd0aCIsIlJhbmdlRXJyb3IiLCJ3cml0ZSIsImVucXVldWUiLCJkb0Nsb3NlIiwic2VuZEZyYW1lIiwicGluZyIsImRvUGluZyIsInBvbmciLCJkb1BvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJfdGhyZXNob2xkIiwib3B0cyIsImRpc3BhdGNoIiwiXyIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwiaSIsImNhbGxiYWNrIiwiZGVxdWV1ZSIsInBhcmFtcyIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/stream.js":
/*!*******************************************!*\
  !*** ./app/node_modules/ws/lib/stream.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */ function emitClose(stream) {\n    stream.emit(\"close\");\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */ function duplexOnEnd() {\n    if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n    }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */ function duplexOnError(err) {\n    this.removeListener(\"error\", duplexOnError);\n    this.destroy();\n    if (this.listenerCount(\"error\") === 0) {\n        // Do not suppress the throwing behavior.\n        this.emit(\"error\", err);\n    }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */ function createWebSocketStream(ws, options) {\n    let resumeOnReceiverDrain = true;\n    let terminateOnDestroy = true;\n    function receiverOnDrain() {\n        if (resumeOnReceiverDrain) ws._socket.resume();\n    }\n    if (ws.readyState === ws.CONNECTING) {\n        ws.once(\"open\", function open() {\n            ws._receiver.removeAllListeners(\"drain\");\n            ws._receiver.on(\"drain\", receiverOnDrain);\n        });\n    } else {\n        ws._receiver.removeAllListeners(\"drain\");\n        ws._receiver.on(\"drain\", receiverOnDrain);\n    }\n    const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n    });\n    ws.on(\"message\", function message(msg) {\n        if (!duplex.push(msg)) {\n            resumeOnReceiverDrain = false;\n            ws._socket.pause();\n        }\n    });\n    ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n        //\n        // - If the `'error'` event is emitted before the `'open'` event, then\n        //   `ws.terminate()` is a noop as no socket is assigned.\n        // - Otherwise, the error is re-emitted by the listener of the `'error'`\n        //   event of the `Receiver` object. The listener already closes the\n        //   connection by calling `ws.close()`. This allows a close frame to be\n        //   sent to the other peer. If `ws.terminate()` is called right after this,\n        //   then the close frame might not be sent.\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n    });\n    ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n    });\n    duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n            callback(err);\n            process.nextTick(emitClose, duplex);\n            return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err) {\n            called = true;\n            callback(err);\n        });\n        ws.once(\"close\", function close() {\n            if (!called) callback(err);\n            process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n    };\n    duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._final(callback);\n            });\n            return;\n        }\n        // If the value of the `_socket` property is `null` it means that `ws` is a\n        // client websocket and the handshake failed. In fact, when this happens, a\n        // socket is never assigned to the websocket. Wait for the `'error'` event\n        // that will be emitted by the websocket.\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n            callback();\n            if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n            ws._socket.once(\"finish\", function finish() {\n                // `duplex` is not destroyed here because the `'end'` event will be\n                // emitted on `duplex` after this `'finish'` event. The EOF signaling\n                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n                callback();\n            });\n            ws.close();\n        }\n    };\n    duplex._read = function() {\n        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {\n            resumeOnReceiverDrain = true;\n            if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n        }\n    };\n    duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._write(chunk, encoding, callback);\n            });\n            return;\n        }\n        ws.send(chunk, callback);\n    };\n    duplex.on(\"end\", duplexOnEnd);\n    duplex.on(\"error\", duplexOnError);\n    return duplex;\n}\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUzQjs7Ozs7Q0FLQyxHQUNELFNBQVNDLFVBQVVDLE1BQU07SUFDdkJBLE9BQU9DLElBQUksQ0FBQztBQUNkO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxRQUFRLEVBQUU7UUFDbkQsSUFBSSxDQUFDQyxPQUFPO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRztJQUN4QixJQUFJLENBQUNDLGNBQWMsQ0FBQyxTQUFTRjtJQUM3QixJQUFJLENBQUNELE9BQU87SUFDWixJQUFJLElBQUksQ0FBQ0ksYUFBYSxDQUFDLGFBQWEsR0FBRztRQUNyQyx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDVCxJQUFJLENBQUMsU0FBU087SUFDckI7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRyxzQkFBc0JDLEVBQUUsRUFBRUMsT0FBTztJQUN4QyxJQUFJQyx3QkFBd0I7SUFDNUIsSUFBSUMscUJBQXFCO0lBRXpCLFNBQVNDO1FBQ1AsSUFBSUYsdUJBQXVCRixHQUFHSyxPQUFPLENBQUNDLE1BQU07SUFDOUM7SUFFQSxJQUFJTixHQUFHTyxVQUFVLEtBQUtQLEdBQUdRLFVBQVUsRUFBRTtRQUNuQ1IsR0FBR1MsSUFBSSxDQUFDLFFBQVEsU0FBU0M7WUFDdkJWLEdBQUdXLFNBQVMsQ0FBQ0Msa0JBQWtCLENBQUM7WUFDaENaLEdBQUdXLFNBQVMsQ0FBQ0UsRUFBRSxDQUFDLFNBQVNUO1FBQzNCO0lBQ0YsT0FBTztRQUNMSixHQUFHVyxTQUFTLENBQUNDLGtCQUFrQixDQUFDO1FBQ2hDWixHQUFHVyxTQUFTLENBQUNFLEVBQUUsQ0FBQyxTQUFTVDtJQUMz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QVEsU0FBU0M7Z0JBQ3ZCSSxPQUFPeUIsTUFBTSxDQUFDQyxPQUFPQyxVQUFVaEI7WUFDakM7WUFDQTtRQUNGO1FBRUF6QixHQUFHMEMsSUFBSSxDQUFDRixPQUFPZjtJQUNqQjtJQUVBWCxPQUFPRCxFQUFFLENBQUMsT0FBT3ZCO0lBQ2pCd0IsT0FBT0QsRUFBRSxDQUFDLFNBQVNsQjtJQUNuQixPQUFPbUI7QUFDVDtBQUVBNkIsT0FBT0MsT0FBTyxHQUFHN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL2FwcC9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcz84ZTVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSB0cnVlO1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gICAgaWYgKHJlc3VtZU9uUmVjZWl2ZXJEcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgfVxuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKCFkdXBsZXgucHVzaChtc2cpKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSBmYWxzZTtcbiAgICAgIHdzLl9zb2NrZXQucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChcbiAgICAgICh3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOIHx8IHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NJTkcpICYmXG4gICAgICAhcmVzdW1lT25SZWNlaXZlckRyYWluXG4gICAgKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSB0cnVlO1xuICAgICAgaWYgKCF3cy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB3cy5fc29ja2V0LnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsImVtaXRDbG9zZSIsInN0cmVhbSIsImVtaXQiLCJkdXBsZXhPbkVuZCIsImRlc3Ryb3llZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJkZXN0cm95IiwiZHVwbGV4T25FcnJvciIsImVyciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIndzIiwib3B0aW9ucyIsInJlc3VtZU9uUmVjZWl2ZXJEcmFpbiIsInRlcm1pbmF0ZU9uRGVzdHJveSIsInJlY2VpdmVyT25EcmFpbiIsIl9zb2NrZXQiLCJyZXN1bWUiLCJyZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIm9uY2UiLCJvcGVuIiwiX3JlY2VpdmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib24iLCJkdXBsZXgiLCJhdXRvRGVzdHJveSIsIm9iamVjdE1vZGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJtZXNzYWdlIiwibXNnIiwicHVzaCIsInBhdXNlIiwiZXJyb3IiLCJjbG9zZSIsIl9kZXN0cm95IiwiY2FsbGJhY2siLCJDTE9TRUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsZWQiLCJ0ZXJtaW5hdGUiLCJfZmluYWwiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJmaW5pc2giLCJfcmVhZCIsIk9QRU4iLCJDTE9TSU5HIiwibmVlZERyYWluIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsInNlbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/validation.js":
/*!***********************************************!*\
  !*** ./app/node_modules/ws/lib/validation.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */ function isValidStatusCode(code) {\n    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */ function _isValidUTF8(buf) {\n    const len = buf.length;\n    let i = 0;\n    while(i < len){\n        if ((buf[i] & 0x80) === 0) {\n            // 0xxxxxxx\n            i++;\n        } else if ((buf[i] & 0xe0) === 0xc0) {\n            // 110xxxxx 10xxxxxx\n            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n            ) {\n                return false;\n            }\n            i += 2;\n        } else if ((buf[i] & 0xf0) === 0xe0) {\n            // 1110xxxx 10xxxxxx 10xxxxxx\n            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n            buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n            ) {\n                return false;\n            }\n            i += 3;\n        } else if ((buf[i] & 0xf8) === 0xf0) {\n            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n            buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n            ) {\n                return false;\n            }\n            i += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\ntry {\n    let isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(ssr)/./app/node_modules/utf-8-validate/index.js\");\n    /* istanbul ignore if */ if (typeof isValidUTF8 === \"object\") {\n        isValidUTF8 = isValidUTF8.Validation.isValidUTF8; // utf-8-validate@<3.0.0\n    }\n    module.exports = {\n        isValidStatusCode,\n        isValidUTF8 (buf) {\n            return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        }\n    };\n} catch (e) /* istanbul ignore next */ {\n    module.exports = {\n        isValidStatusCode,\n        isValidUTF8: _isValidUTF8\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0Esa0JBQWtCQyxJQUFJO0lBQzdCLE9BQ0UsUUFBUyxRQUNQQSxRQUFRLFFBQ1JBLFNBQVMsUUFDVEEsU0FBUyxRQUNUQSxTQUFTLFFBQ1ZBLFFBQVEsUUFBUUEsUUFBUTtBQUU3QjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsYUFBYUMsR0FBRztJQUN2QixNQUFNQyxNQUFNRCxJQUFJRSxNQUFNO0lBQ3RCLElBQUlDLElBQUk7SUFFUixNQUFPQSxJQUFJRixJQUFLO1FBQ2QsSUFBSSxDQUFDRCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sR0FBRztZQUN6QixXQUFXO1lBQ1hBO1FBQ0YsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBQ0csRUFBRSxHQUFHLElBQUcsTUFBTyxNQUFNO1lBQ25DLG9CQUFvQjtZQUNwQixJQUNFQSxJQUFJLE1BQU1GLE9BQ1YsQ0FBQ0QsR0FBRyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxJQUFHLE1BQU8sUUFDeEIsQ0FBQ0gsR0FBRyxDQUFDRyxFQUFFLEdBQUcsSUFBRyxNQUFPLEtBQUssV0FBVztjQUNwQztnQkFDQSxPQUFPO1lBQ1Q7WUFFQUEsS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDSCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFBTTtZQUNuQyw2QkFBNkI7WUFDN0IsSUFDRUEsSUFBSSxLQUFLRixPQUNULENBQUNELEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3ZCSCxHQUFHLENBQUNHLEVBQUUsS0FBSyxRQUFRLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQVMsV0FBVztZQUMvREgsR0FBRyxDQUFDRyxFQUFFLEtBQUssUUFBUSxDQUFDSCxHQUFHLENBQUNHLElBQUksRUFBRSxHQUFHLElBQUcsTUFBTyxLQUFNLDhCQUE4QjtjQUNoRjtnQkFDQSxPQUFPO1lBQ1Q7WUFFQUEsS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDSCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFBTTtZQUNuQyxzQ0FBc0M7WUFDdEMsSUFDRUEsSUFBSSxLQUFLRixPQUNULENBQUNELEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3ZCSCxHQUFHLENBQUNHLEVBQUUsS0FBSyxRQUFRLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQVMsV0FBVztZQUMvREgsR0FBRyxDQUFDRyxFQUFFLEtBQUssUUFBUUgsR0FBRyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxRQUNqQ0gsR0FBRyxDQUFDRyxFQUFFLEdBQUcsS0FBSyxhQUFhO2NBQzNCO2dCQUNBLE9BQU87WUFDVDtZQUVBQSxLQUFLO1FBQ1AsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSTtJQUNGLElBQUlDLGNBQWNDLG1CQUFPQSxDQUFDO0lBRTFCLHNCQUFzQixHQUN0QixJQUFJLE9BQU9ELGdCQUFnQixVQUFVO1FBQ25DQSxjQUFjQSxZQUFZRSxVQUFVLENBQUNGLFdBQVcsRUFBRSx3QkFBd0I7SUFDNUU7SUFFQUcsT0FBT0MsT0FBTyxHQUFHO1FBQ2ZYO1FBQ0FPLGFBQVlKLEdBQUc7WUFDYixPQUFPQSxJQUFJRSxNQUFNLEdBQUcsTUFBTUgsYUFBYUMsT0FBT0ksWUFBWUo7UUFDNUQ7SUFDRjtBQUNGLEVBQUUsT0FBT1MsR0FBRyx3QkFBd0IsR0FBRztJQUNyQ0YsT0FBT0MsT0FBTyxHQUFHO1FBQ2ZYO1FBQ0FPLGFBQWFMO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcz9mNTUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudHJ5IHtcbiAgbGV0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpc1ZhbGlkVVRGOCA9PT0gJ29iamVjdCcpIHtcbiAgICBpc1ZhbGlkVVRGOCA9IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjg7IC8vIHV0Zi04LXZhbGlkYXRlQDwzLjAuMFxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjgoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDE1MCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9XG4gIH07XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjhcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJpc1ZhbGlkU3RhdHVzQ29kZSIsImNvZGUiLCJfaXNWYWxpZFVURjgiLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJpIiwiaXNWYWxpZFVURjgiLCJyZXF1aXJlIiwiVmFsaWRhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/websocket-server.js":
/*!*****************************************************!*\
  !*** ./app/node_modules/ws/lib/websocket-server.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./app/node_modules/ws/lib/permessage-deflate.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./app/node_modules/ws/lib/websocket.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./app/node_modules/ws/lib/extension.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [callback] A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = {\n            maxPayload: 100 * 1024 * 1024,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null,\n            ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n            throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            const emitConnection = this.emit.bind(this, \"connection\");\n            this._removeListeners = addListeners(this._server, {\n                listening: this.emit.bind(this, \"listening\"),\n                error: this.emit.bind(this, \"error\"),\n                upgrade: (req, socket, head)=>{\n                    this.handleUpgrade(req, socket, head, emitConnection);\n                }\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) this.clients = new Set();\n        this.options = options;\n        this._state = RUNNING;\n    }\n    /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */ address() {\n        if (this.options.noServer) {\n            throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n    }\n    /**\n   * Close the server.\n   *\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(cb) {\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSED) {\n            process.nextTick(emitClose, this);\n            return;\n        }\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        //\n        // Terminate all associated clients.\n        //\n        if (this.clients) {\n            for (const client of this.clients)client.terminate();\n        }\n        const server = this._server;\n        if (server) {\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n            //\n            // Close the http server if it was internally created.\n            //\n            if (this.options.port != null) {\n                server.close(emitClose.bind(undefined, this));\n                return;\n            }\n        }\n        process.nextTick(emitClose, this);\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path) {\n            const index = req.url.indexOf(\"?\");\n            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n            if (pathname !== this.options.path) return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"] !== undefined ? req.headers[\"sec-websocket-key\"].trim() : false;\n        const version = +req.headers[\"sec-websocket-version\"];\n        const extensions = {};\n        if (req.method !== \"GET\" || req.headers.upgrade.toLowerCase() !== \"websocket\" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n            return abortHandshake(socket, 400);\n        }\n        if (this.options.perMessageDeflate) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = parse(req.headers[\"sec-websocket-extensions\"]);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                return abortHandshake(socket, 400);\n            }\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.socket.authorized || req.socket.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message, headers)=>{\n                    if (!verified) {\n                        return abortHandshake(socket, code || 401, message, headers);\n                    }\n                    this.completeUpgrade(key, extensions, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(key, extensions, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */ completeUpgrade(key, extensions, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n            throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new WebSocket(null);\n        let protocol = req.headers[\"sec-websocket-protocol\"];\n        if (protocol) {\n            protocol = protocol.split(\",\").map(trim);\n            //\n            // Optionally call external protocol selection handler.\n            //\n            if (this.options.handleProtocols) {\n                protocol = this.options.handleProtocols(protocol, req);\n            } else {\n                protocol = protocol[0];\n            }\n            if (protocol) {\n                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                ws._protocol = protocol;\n            }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n            ws._extensions = extensions;\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, this.options.maxPayload);\n        if (this.clients) {\n            this.clients.add(ws);\n            ws.on(\"close\", ()=>this.clients.delete(ws));\n        }\n        cb(ws, req);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */ function addListeners(server, map) {\n    for (const event of Object.keys(map))server.on(event, map[event]);\n    return function removeListeners() {\n        for (const event of Object.keys(map)){\n            server.removeListener(event, map[event]);\n        }\n    };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */ function emitClose(server) {\n    server._state = CLOSED;\n    server.emit(\"close\");\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */ function socketOnError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */ function abortHandshake(socket, code, message, headers) {\n    if (socket.writable) {\n        message = message || http.STATUS_CODES[code];\n        headers = {\n            Connection: \"close\",\n            \"Content-Type\": \"text/html\",\n            \"Content-Length\": Buffer.byteLength(message),\n            ...headers\n        };\n        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n    }\n    socket.removeListener(\"error\", socketOnError);\n    socket.destroy();\n}\n/**\n * Remove whitespace characters from both ends of a string.\n *\n * @param {String} str The string\n * @return {String} A new string representing `str` stripped of whitespace\n *     characters from both its beginning and end\n * @private\n */ function trim(str) {\n    return str.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdGQUFnRixHQUVoRjtBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRUssVUFBVSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBRS9CLE1BQU1NLG9CQUFvQk4sbUJBQU9BLENBQUM7QUFDbEMsTUFBTU8sWUFBWVAsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFUSxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVVLElBQUksRUFBRUMsVUFBVSxFQUFFLEdBQUdYLG1CQUFPQSxDQUFDO0FBRXJDLE1BQU1ZLFdBQVc7QUFFakIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFNBQVM7QUFFZjs7OztDQUlDLEdBQ0QsTUFBTUMsd0JBQXdCakI7SUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCQyxHQUNEa0IsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsS0FBSztRQUVMRCxVQUFVO1lBQ1JFLFlBQVksTUFBTSxPQUFPO1lBQ3pCQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsZ0JBQWdCO1lBQ2hCQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsU0FBUztZQUNUQyxRQUFRO1lBQ1JDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxNQUFNO1lBQ04sR0FBR1osT0FBTztRQUNaO1FBRUEsSUFDRSxRQUFTWSxJQUFJLElBQUksUUFBUSxDQUFDWixRQUFRUyxNQUFNLElBQUksQ0FBQ1QsUUFBUU8sUUFBUSxJQUM1RFAs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Q0FBQyxDQUFDLEVBQ2hDZCxJQUFJLENBQUMsVUFDUixhQUNBbEI7SUFFTjtJQUVBN0MsT0FBT2dFLGNBQWMsQ0FBQyxTQUFTeEM7SUFDL0J4QixPQUFPaUQsT0FBTztBQUNoQjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTdEIsS0FBS21ELEdBQUc7SUFDZixPQUFPQSxJQUFJbkQsSUFBSTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vYXBwL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcz9iZWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHN8aHR0cHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2xvc2UgdGhlIGh0dHAgc2VydmVyIGlmIGl0IHdhcyBpbnRlcm5hbGx5IGNyZWF0ZWQuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyLmNsb3NlKGVtaXRDbG9zZS5iaW5kKHVuZGVmaW5lZCwgdGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10udHJpbSgpXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFrZXkgfHxcbiAgICAgICFrZXlSZWdleC50ZXN0KGtleSkgfHxcbiAgICAgICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB8fFxuICAgICAgIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSlcbiAgICApIHtcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IHBhcnNlKHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGtleSwgZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGtleSwgZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlVXBncmFkZShrZXksIGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQobnVsbCk7XG4gICAgbGV0IHByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcblxuICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnLCcpLm1hcCh0cmltKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scykge1xuICAgICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHRoaXMuY2xpZW50cy5kZWxldGUod3MpKTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgdGhpcy5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBwcmVjb25kaXRpb25zIGFyZSBub3QgZnVsZmlsbGVkLlxuICpcbiAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcsXG4gICAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9O1xuXG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICAgJ1xcclxcblxcclxcbicgK1xuICAgICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgc29ja2V0LmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGZyb20gYm90aCBlbmRzIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgcmVwcmVzZW50aW5nIGBzdHJgIHN0cmlwcGVkIG9mIHdoaXRlc3BhY2VcbiAqICAgICBjaGFyYWN0ZXJzIGZyb20gYm90aCBpdHMgYmVnaW5uaW5nIGFuZCBlbmRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwIiwiaHR0cHMiLCJuZXQiLCJ0bHMiLCJjcmVhdGVIYXNoIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJXZWJTb2NrZXQiLCJmb3JtYXQiLCJwYXJzZSIsIkdVSUQiLCJrV2ViU29ja2V0Iiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiQ0xPU0lORyIsIkNMT1NFRCIsIldlYlNvY2tldFNlcnZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNhbGxiYWNrIiwibWF4UGF5bG9hZCIsInBlck1lc3NhZ2VEZWZsYXRlIiwiaGFuZGxlUHJvdG9jb2xzIiwiY2xpZW50VHJhY2tpbmciLCJ2ZXJpZnlDbGllbnQiLCJub1NlcnZlciIsImJhY2tsb2ciLCJzZXJ2ZXIiLCJob3N0IiwicGF0aCIsInBvcnQiLCJUeXBlRXJyb3IiLCJfc2VydmVyIiwiY3JlYXRlU2VydmVyIiwicmVxIiwicmVzIiwiYm9keSIsIlNUQVRVU19DT0RFUyIsIndyaXRlSGVhZCIsImxlbmd0aCIsImVuZCIsImxpc3RlbiIsImVtaXRDb25uZWN0aW9uIiwiZW1pdCIsImJpbmQiLCJfcmVtb3ZlTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXJzIiwibGlzdGVuaW5nIiwiZXJyb3IiLCJ1cGdyYWRlIiwic29ja2V0IiwiaGVhZCIsImhhbmRsZVVwZ3JhZGUiLCJjbGllbnRzIiwiU2V0IiwiX3N0YXRlIiwiYWRkcmVzcyIsIkVycm9yIiwiY2xvc2UiLCJjYiIsIm9uY2UiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0Q2xvc2UiLCJjbGllbnQiLCJ0ZXJtaW5hdGUiLCJ1bmRlZmluZWQiLCJzaG91bGRIYW5kbGUiLCJpbmRleCIsInVybCIsImluZGV4T2YiLCJwYXRobmFtZSIsInNsaWNlIiwib24iLCJzb2NrZXRPbkVycm9yIiwia2V5IiwiaGVhZGVycyIsInRyaW0iLCJ2ZXJzaW9uIiwiZXh0ZW5zaW9ucyIsIm1ldGhvZCIsInRvTG93ZXJDYXNlIiwidGVzdCIsImFib3J0SGFuZHNoYWtlIiwib2ZmZXJzIiwiZXh0ZW5zaW9uTmFtZSIsImFjY2VwdCIsImVyciIsImluZm8iLCJvcmlnaW4iLCJzZWN1cmUiLCJhdXRob3JpemVkIiwiZW5jcnlwdGVkIiwidmVyaWZpZWQiLCJjb2RlIiwibWVzc2FnZSIsImNvbXBsZXRlVXBncmFkZSIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJkZXN0cm95IiwiZGlnZXN0IiwidXBkYXRlIiwid3MiLCJwcm90b2NvbCIsInNwbGl0IiwibWFwIiwicHVzaCIsIl9wcm90b2NvbCIsInBhcmFtcyIsInZhbHVlIiwiX2V4dGVuc2lvbnMiLCJ3cml0ZSIsImNvbmNhdCIsImpvaW4iLCJyZW1vdmVMaXN0ZW5lciIsInNldFNvY2tldCIsImFkZCIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJldmVudCIsIk9iamVjdCIsImtleXMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJDb25uZWN0aW9uIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImgiLCJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./app/node_modules/ws/lib/websocket.js":
/*!**********************************************!*\
  !*** ./app/node_modules/ws/lib/websocket.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./app/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./app/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./app/node_modules/ws/lib/sender.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, GUID, kStatusCode, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./app/node_modules/ws/lib/constants.js\");\nconst { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ \"(ssr)/./app/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./app/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./app/node_modules/ws/lib/buffer-util.js\");\nconst readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nconst protocolVersions = [\n    8,\n    13\n];\nconst closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */ constructor(address, protocols, options){\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = \"\";\n        this._closeTimer = null;\n        this._extensions = {};\n        this._protocol = \"\";\n        this._readyState = WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n            this._bufferedAmount = 0;\n            this._isServer = false;\n            this._redirects = 0;\n            if (Array.isArray(protocols)) {\n                protocols = protocols.join(\", \");\n            } else if (typeof protocols === \"object\" && protocols !== null) {\n                options = protocols;\n                protocols = undefined;\n            }\n            initAsClient(this, address, protocols, options);\n        } else {\n            this._isServer = true;\n        }\n    }\n    /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n   * @type {String}\n   */ get extensions() {\n        return Object.keys(this._extensions).join();\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onclose() {\n        return undefined;\n    }\n    /* istanbul ignore next */ set onclose(listener) {}\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onerror() {\n        return undefined;\n    }\n    /* istanbul ignore next */ set onerror(listener) {}\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onopen() {\n        return undefined;\n    }\n    /* istanbul ignore next */ set onopen(listener) {}\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onmessage() {\n        return undefined;\n    }\n    /* istanbul ignore next */ set onmessage(listener) {}\n    /**\n   * @type {String}\n   */ get protocol() {\n        return this._protocol;\n    }\n    /**\n   * @type {Number}\n   */ get readyState() {\n        return this._readyState;\n    }\n    /**\n   * @type {String}\n   */ get url() {\n        return this._url;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} [maxPayload=0] The maximum allowed message size\n   * @private\n   */ setSocket(socket, head, maxPayload) {\n        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);\n        this._sender = new Sender(socket, this._extensions);\n        this._receiver = receiver;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        socket.setTimeout(0);\n        socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */ emitClose() {\n        if (!this._socket) {\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n            return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n            this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {String} [data] A string explaining why the connection is closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            return abortHandshake(this, this._req, msg);\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                this._socket.end();\n            }\n            return;\n        }\n        this._readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                this._socket.end();\n            }\n        });\n        //\n        // Specify a timeout for the closing handshake to complete.\n        //\n        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n    /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */ ping(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */ pong(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        const opts = {\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true,\n            ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            return abortHandshake(this, this._req, msg);\n        }\n        if (this._socket) {\n            this._readyState = WebSocket.CLOSING;\n            this._socket.destroy();\n        }\n    }\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"protocol\",\n    \"readyState\",\n    \"url\"\n].forEach((property)=>{\n    Object.defineProperty(WebSocket.prototype, property, {\n        enumerable: true\n    });\n});\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        enumerable: true,\n        get () {\n            const listeners = this.listeners(method);\n            for(let i = 0; i < listeners.length; i++){\n                if (listeners[i]._listener) return listeners[i]._listener;\n            }\n            return undefined;\n        },\n        set (listener) {\n            const listeners = this.listeners(method);\n            for(let i = 0; i < listeners.length; i++){\n                //\n                // Remove only the listeners added via `addEventListener`.\n                //\n                if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n            }\n            this.addEventListener(method, listener);\n        }\n    });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {String} [protocols] The subprotocols\n * @param {Object} [options] Connection options\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @private\n */ function initAsClient(websocket, address, protocols, options) {\n    const opts = {\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        createConnection: undefined,\n        socketPath: undefined,\n        hostname: undefined,\n        protocol: undefined,\n        timeout: undefined,\n        method: undefined,\n        host: undefined,\n        path: undefined,\n        port: undefined\n    };\n    if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    let parsedUrl;\n    if (address instanceof URL) {\n        parsedUrl = address;\n        websocket._url = address.href;\n    } else {\n        parsedUrl = new URL(address);\n        websocket._url = address;\n    }\n    const isUnixSocket = parsedUrl.protocol === \"ws+unix:\";\n    if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n        const err = new Error(`Invalid URL: ${websocket.url}`);\n        if (websocket._redirects === 0) {\n            throw err;\n        } else {\n            emitErrorAndClose(websocket, err);\n            return;\n        }\n    }\n    const isSecure = parsedUrl.protocol === \"wss:\" || parsedUrl.protocol === \"https:\";\n    const defaultPort = isSecure ? 443 : 80;\n    const key = randomBytes(16).toString(\"base64\");\n    const get = isSecure ? https.get : http.get;\n    let perMessageDeflate;\n    opts.createConnection = isSecure ? tlsConnect : netConnect;\n    opts.defaultPort = opts.defaultPort || defaultPort;\n    opts.port = parsedUrl.port || defaultPort;\n    opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n    opts.headers = {\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\",\n        ...opts.headers\n    };\n    opts.path = parsedUrl.pathname + parsedUrl.search;\n    opts.timeout = opts.handshakeTimeout;\n    if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (protocols) {\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols;\n    }\n    if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n            opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n            opts.headers.Origin = opts.origin;\n        }\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n    }\n    if (isUnixSocket) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n    }\n    if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n            websocket._originalUnixSocket = isUnixSocket;\n            websocket._originalSecure = isSecure;\n            websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;\n            const headers = options && options.headers;\n            //\n            // Shallow copy the user provided options so that headers can be changed\n            // without mutating the original object.\n            //\n            options = {\n                ...options,\n                headers: {}\n            };\n            if (headers) {\n                for (const [key, value] of Object.entries(headers)){\n                    options.headers[key.toLowerCase()] = value;\n                }\n            }\n        } else {\n            const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n            if (!isSameHost || websocket._originalSecure && !isSecure) {\n                //\n                // Match curl 7.77.0 behavior and drop the following headers. These\n                // headers are also dropped when following a redirect to a subdomain.\n                //\n                delete opts.headers.authorization;\n                delete opts.headers.cookie;\n                if (!isSameHost) delete opts.headers.host;\n                opts.auth = undefined;\n            }\n        }\n        //\n        // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n        // If the `Authorization` header is set, then there is nothing to do as it\n        // will take precedence.\n        //\n        if (opts.auth && !options.headers.authorization) {\n            options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n    }\n    let req = websocket._req = get(opts);\n    if (opts.timeout) {\n        req.on(\"timeout\", ()=>{\n            abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n    }\n    req.on(\"error\", (err)=>{\n        if (req === null || req.aborted) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n    });\n    req.on(\"response\", (res)=>{\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n            if (++websocket._redirects > opts.maxRedirects) {\n                abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                return;\n            }\n            req.abort();\n            let addr;\n            try {\n                addr = new URL(location, address);\n            } catch (err) {\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n            initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n        }\n    });\n    req.on(\"upgrade\", (res, socket, head)=>{\n        websocket.emit(\"upgrade\", res);\n        //\n        // The user may have closed the connection from a listener of the `upgrade`\n        // event.\n        //\n        if (websocket.readyState !== WebSocket.CONNECTING) return;\n        req = websocket._req = null;\n        if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n            abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n            return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n            return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        const protList = (protocols || \"\").split(/, */);\n        let protError;\n        if (!protocols && serverProt) {\n            protError = \"Server sent a subprotocol but none was requested\";\n        } else if (protocols && !serverProt) {\n            protError = \"Server sent no subprotocol\";\n        } else if (serverProt && !protList.includes(serverProt)) {\n            protError = \"Server sent an invalid subprotocol\";\n        }\n        if (protError) {\n            abortHandshake(websocket, socket, protError);\n            return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== undefined) {\n            if (!perMessageDeflate) {\n                const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            let extensions;\n            try {\n                extensions = parse(secWebSocketExtensions);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            const extensionNames = Object.keys(extensions);\n            if (extensionNames.length) {\n                if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                    const message = \"Server indicated an extension that was not requested\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                try {\n                    perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n                } catch (err) {\n                    const message = \"Invalid Sec-WebSocket-Extensions header\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n            }\n        }\n        websocket.setSocket(socket, head, opts.maxPayload);\n    });\n}\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */ function emitErrorAndClose(websocket, err) {\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit(\"error\", err);\n    websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */ function netConnect(options) {\n    options.path = options.socketPath;\n    return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */ function tlsConnect(options) {\n    options.path = undefined;\n    if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n    }\n    return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */ function abortHandshake(websocket, stream, message) {\n    websocket._readyState = WebSocket.CLOSING;\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshake);\n    if (stream.setHeader) {\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n            //\n            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n            // called after the request completed. See\n            // https://github.com/websockets/ws/issues/1869.\n            //\n            stream.socket.destroy();\n        }\n        stream.once(\"abort\", websocket.emitClose.bind(websocket));\n        websocket.emit(\"error\", err);\n    } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n    }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */ function sendAfterClose(websocket, data, cb) {\n    if (data) {\n        const length = toBuffer(data).length;\n        //\n        // The `_bufferedAmount` property is used only when the peer is a client and\n        // the opening handshake fails. Under these circumstances, in fact, the\n        // `setSocket()` method is not called, so the `_socket` and `_sender`\n        // properties are set to `null`.\n        //\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n    }\n    if (cb) {\n        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n        cb(err);\n    }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */ function receiverOnConclude(code, reason) {\n    const websocket = this[kWebSocket];\n    websocket._closeFrameReceived = true;\n    websocket._closeMessage = reason;\n    websocket._closeCode = code;\n    if (websocket._socket[kWebSocket] === undefined) return;\n    websocket._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket._socket);\n    if (code === 1005) websocket.close();\n    else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */ function receiverOnDrain() {\n    this[kWebSocket]._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */ function receiverOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket._socket[kWebSocket] !== undefined) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        //\n        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n        // https://github.com/websockets/ws/issues/1940.\n        //\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n    }\n    websocket.emit(\"error\", err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */ function receiverOnFinish() {\n    this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */ function receiverOnMessage(data) {\n    this[kWebSocket].emit(\"message\", data);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */ function receiverOnPing(data) {\n    const websocket = this[kWebSocket];\n    websocket.pong(data, !websocket._isServer, NOOP);\n    websocket.emit(\"ping\", data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */ function receiverOnPong(data) {\n    this[kWebSocket].emit(\"pong\", data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */ function resume(stream) {\n    stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */ function socketOnClose() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"close\", socketOnClose);\n    this.removeListener(\"data\", socketOnData);\n    this.removeListener(\"end\", socketOnEnd);\n    websocket._readyState = WebSocket.CLOSING;\n    let chunk;\n    //\n    // The close frame might not have been received or the `'end'` event emitted,\n    // for example, if the socket was destroyed due to an error. Ensure that the\n    // `receiver` stream is closed after writing any remaining buffered data to\n    // it. If the readable side of the socket is in flowing mode then there is no\n    // buffered data as everything has been already written and `readable.read()`\n    // will return `null`. If instead, the socket is paused, any possible buffered\n    // data will be read as a single chunk.\n    //\n    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n    }\n    websocket._receiver.end();\n    this[kWebSocket] = undefined;\n    clearTimeout(websocket._closeTimer);\n    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n    } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n    }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function socketOnData(chunk) {\n    if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */ function socketOnEnd() {\n    const websocket = this[kWebSocket];\n    websocket._readyState = WebSocket.CLOSING;\n    websocket._receiver.end();\n    this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */ function socketOnError() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"error\", socketOnError);\n    this.on(\"error\", NOOP);\n    if (websocket) {\n        websocket._readyState = WebSocket.CLOSING;\n        this.destroy();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkVBQTJFLEdBRTNFO0FBRUEsTUFBTUEsZUFBZUMsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUksTUFBTUosbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFSyxXQUFXLEVBQUVDLFVBQVUsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM1QyxNQUFNLEVBQUVPLFFBQVEsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVRLEdBQUcsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUV4QixNQUFNUyxvQkFBb0JULG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1VLFdBQVdWLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1XLFNBQVNYLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSlksWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLElBQUksRUFDSkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLElBQUksRUFDTCxHQUFHakIsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVrQixnQkFBZ0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR25CLG1CQUFPQSxDQUFDO0FBQzFELE1BQU0sRUFBRW9CLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVzQixRQUFRLEVBQUUsR0FBR3RCLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU11QixjQUFjO0lBQUM7SUFBYztJQUFRO0lBQVc7Q0FBUztBQUMvRCxNQUFNQyxtQkFBbUI7SUFBQztJQUFHO0NBQUc7QUFDaEMsTUFBTUMsZUFBZSxLQUFLO0FBRTFCOzs7O0NBSUMsR0FDRCxNQUFNQyxrQkFBa0IzQjtJQUN0Qjs7Ozs7O0dBTUMs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SUFDZDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9hcHAvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanM/MmQyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5SZWFkYWJsZSRcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlELFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldCxcbiAgTk9PUFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCB7IHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBwcm90b2NvbHMgPSBwcm90b2NvbHMuam9pbignLCAnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgIHByb3RvY29scyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldCBvbmNsb3NlKGxpc3RlbmVyKSB7fVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0IG9uZXJyb3IobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldCBvbm9wZW4obGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldCBvbm1lc3NhZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBtYXhQYXlsb2FkKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoXG4gICAgICB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkXG4gICAgKTtcblxuICAgIHRoaXMuX3NlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGFdIEEgc3RyaW5nIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSByZXR1cm4gbGlzdGVuZXJzW2ldLl9saXN0ZW5lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlbW92ZSBvbmx5IHRoZSBsaXN0ZW5lcnMgYWRkZWQgdmlhIGBhZGRFdmVudExpc3RlbmVyYC5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcy5ocmVmO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzO1xuICB9XG5cbiAgY29uc3QgaXNVbml4U29ja2V0ID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuXG4gIGlmICghcGFyc2VkVXJsLmhvc3QgJiYgKCFpc1VuaXhTb2NrZXQgfHwgIXBhcnNlZFVybC5wYXRobmFtZSkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke3dlYnNvY2tldC51cmx9YCk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzU2VjdXJlID1cbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3c3M6JyB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IGdldCA9IGlzU2VjdXJlID8gaHR0cHMuZ2V0IDogaHR0cC5nZXQ7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0O1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnLFxuICAgIC4uLm9wdHMuaGVhZGVyc1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHM7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzVW5peFNvY2tldCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvbGxvd1JlZGlyZWN0cykge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbFVuaXhTb2NrZXQgPSBpc1VuaXhTb2NrZXQ7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzVW5peFNvY2tldFxuICAgICAgICA/IG9wdHMuc29ja2V0UGF0aFxuICAgICAgICA6IHBhcnNlZFVybC5ob3N0O1xuXG4gICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnM7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHVzZXIgcHJvdmlkZWQgb3B0aW9ucyBzbyB0aGF0IGhlYWRlcnMgY2FuIGJlIGNoYW5nZWRcbiAgICAgIC8vIHdpdGhvdXQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgIC8vXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7fSB9O1xuXG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNVbml4U29ja2V0XG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbFVuaXhTb2NrZXRcbiAgICAgICAgICA/IG9wdHMuc29ja2V0UGF0aCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGhcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIDogd2Vic29ja2V0Ll9vcmlnaW5hbFVuaXhTb2NrZXRcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcblxuICAgICAgaWYgKCFpc1NhbWVIb3N0IHx8ICh3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlICYmICFpc1NlY3VyZSkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIGRyb3AgdGhlIGZvbGxvd2luZyBoZWFkZXJzLiBUaGVzZVxuICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cbiAgICAgICAgLy9cbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcblxuICAgICAgICBpZiAoIWlzU2FtZUhvc3QpIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcblxuICAgICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgbWFrZSB0aGUgZmlyc3QgYEF1dGhvcml6YXRpb25gIGhlYWRlciB3aW4uXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcbiAgICAvLyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9XG4gICAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgaWYgKHJlcy5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGNvbnN0IHByb3RMaXN0ID0gKHByb3RvY29scyB8fCAnJykuc3BsaXQoLywgKi8pO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoIXByb3RvY29scyAmJiBzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICB9IGVsc2UgaWYgKHByb3RvY29scyAmJiAhc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9IGVsc2UgaWYgKHNlcnZlclByb3QgJiYgIXByb3RMaXN0LmluY2x1ZGVzKHNlcnZlclByb3QpKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5fcHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgJ1NlcnZlciBzZW50IGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBidXQgbm8gZXh0ZW5zaW9uICcgK1xuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnNpb25zO1xuXG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcblxuICAgICAgaWYgKGV4dGVuc2lvbk5hbWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdHMubWF4UGF5bG9hZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5wb25nKGRhdGEsICF3ZWJzb2NrZXQuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgbGV0IGNodW5rO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cbiAgLy9cbiAgaWYgKFxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXG4gICkge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG5cbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcblxuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzLmVuZCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cbiAgaWYgKHdlYnNvY2tldCkge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImh0dHBzIiwiaHR0cCIsIm5ldCIsInRscyIsInJhbmRvbUJ5dGVzIiwiY3JlYXRlSGFzaCIsIlJlYWRhYmxlIiwiVVJMIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJSZWNlaXZlciIsIlNlbmRlciIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsIkdVSUQiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJOT09QIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmb3JtYXQiLCJwYXJzZSIsInRvQnVmZmVyIiwicmVhZHlTdGF0ZXMiLCJwcm90b2NvbFZlcnNpb25zIiwiY2xvc2VUaW1lb3V0IiwiV2ViU29ja2V0IiwiY29uc3RydWN0b3IiLCJhZGRyZXNzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIl9iaW5hcnlUeXBlIiwiX2Nsb3NlQ29kZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfZXh0ZW5zaW9ucyIsIl9wcm90b2NvbCIsIl9yZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsIl9zZW5kZXIiLCJfc29ja2V0IiwiX2J1ZmZlcmVkQW1vdW50IiwiX2lzU2VydmVyIiwiX3JlZGlyZWN0cyIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJ1bmRlZmluZWQiLCJpbml0QXNDbGllbnQiLCJiaW5hcnlUeXBlIiwidHlwZSIsImluY2x1ZGVzIiwiYnVmZmVyZWRBbW91bnQiLCJfd3JpdGFibGVTdGF0ZSIsImxlbmd0aCIsIl9idWZmZXJlZEJ5dGVzIiwiZXh0ZW5zaW9ucyIsIk9iamVjdCIsImtleXMiLCJvbmNsb3NlIiwibGlzdGVuZXIiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJtYXhQYXlsb2FkIiwicmVjZWl2ZXIiLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNldFRpbWVvdXQiLCJzZXROb0RlbGF5IiwidW5zaGlmdCIsInNvY2tldE9uQ2xvc2UiLCJzb2NrZXRPbkRhdGEiLCJzb2NrZXRPbkVuZCIsInNvY2tldE9uRXJyb3IiLCJPUEVOIiwiZW1pdCIsImVtaXRDbG9zZSIsIkNMT1NFRCIsImV4dGVuc2lvbk5hbWUiLCJjbGVhbnVwIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiY2xvc2UiLCJjb2RlIiwiZGF0YSIsIm1zZyIsImFib3J0SGFuZHNoYWtlIiwiX3JlcSIsIkNMT1NJTkciLCJlcnJvckVtaXR0ZWQiLCJlbmQiLCJlcnIiLCJkZXN0cm95IiwiYmluZCIsInBpbmciLCJtYXNrIiwiY2IiLCJFcnJvciIsInRvU3RyaW5nIiwic2VuZEFmdGVyQ2xvc2UiLCJwb25nIiwic2VuZCIsIm9wdHMiLCJiaW5hcnkiLCJjb21wcmVzcyIsImZpbiIsInRlcm1pbmF0ZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsInZhbHVlIiwiaW5kZXhPZiIsInByb3RvdHlwZSIsImZvckVhY2giLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsImxpc3RlbmVycyIsImkiLCJfbGlzdGVuZXIiLCJzZXQiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3ZWJzb2NrZXQiLCJwcm90b2NvbFZlcnNpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImZvbGxvd1JlZGlyZWN0cyIsIm1heFJlZGlyZWN0cyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJzb2NrZXRQYXRoIiwiaG9zdG5hbWUiLCJ0aW1lb3V0IiwiaG9zdCIsInBhdGgiLCJwb3J0IiwiUmFuZ2VFcnJvciIsInBhcnNlZFVybCIsImhyZWYiLCJpc1VuaXhTb2NrZXQiLCJwYXRobmFtZSIsImVtaXRFcnJvckFuZENsb3NlIiwiaXNTZWN1cmUiLCJkZWZhdWx0UG9ydCIsImtleSIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiaGVhZGVycyIsIkNvbm5lY3Rpb24iLCJVcGdyYWRlIiwic2VhcmNoIiwiaGFuZHNoYWtlVGltZW91dCIsIm9mZmVyIiwib3JpZ2luIiwiT3JpZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJwYXJ0cyIsInNwbGl0IiwiX29yaWdpbmFsVW5peFNvY2tldCIsIl9vcmlnaW5hbFNlY3VyZSIsIl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGgiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJpc1NhbWVIb3N0IiwiYXV0aG9yaXphdGlvbiIsImNvb2tpZSIsIkJ1ZmZlciIsImZyb20iLCJyZXEiLCJhYm9ydGVkIiwicmVzIiwibG9jYXRpb24iLCJzdGF0dXNDb2RlIiwiYWJvcnQiLCJhZGRyIiwidXBncmFkZSIsImRpZ2VzdCIsInVwZGF0ZSIsInNlcnZlclByb3QiLCJwcm90TGlzdCIsInByb3RFcnJvciIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJtZXNzYWdlIiwiZXh0ZW5zaW9uTmFtZXMiLCJhY2NlcHQiLCJjb25uZWN0Iiwic2VydmVybmFtZSIsImlzSVAiLCJzdHJlYW0iLCJjYXB0dXJlU3RhY2tUcmFjZSIsInNldEhlYWRlciIsImRlc3Ryb3llZCIsIm9uY2UiLCJyZWFzb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJyZXN1bWUiLCJyZWNlaXZlck9uRmluaXNoIiwiY2h1bmsiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZWFkIiwid3JpdGUiLCJjbGVhclRpbWVvdXQiLCJmaW5pc2hlZCIsInBhdXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/node_modules/ws/lib/websocket.js\n");

/***/ })

};
;